{"id":"tick-77cbba","title":"Portal","status":"open","priority":2,"created":"2026-02-22T21:28:04Z","updated":"2026-02-22T21:28:04Z"}
{"id":"tick-57d5a4","title":"Phase 1: Walking Skeleton -- Session List and Attach","status":"done","priority":2,"parent":"tick-77cbba","created":"2026-02-22T21:28:07Z","updated":"2026-02-23T14:07:17Z","closed":"2026-02-23T14:07:17Z"}
{"id":"tick-fc2921","title":"Go Module and Cobra Root Command","status":"done","priority":2,"description":"**Problem**: No Go project exists yet. Portal needs an initialised Go module with a CLI framework (Cobra) and the portal open subcommand wired up as the entry point for the TUI.\n\n**Solution**: Initialise a Go module, add Cobra as a dependency, and create the root command (portal) with an open subcommand that prints a placeholder.\n\n**Outcome**: go build produces a portal binary. portal open prints a placeholder message and exits cleanly.\n\n**Do**:\n- Run go mod init github.com/leeovery/portal\n- Add Cobra dependency: go get github.com/spf13/cobra@latest\n- Add Bubble Tea dependency: go get github.com/charmbracelet/bubbletea@latest\n- Create main.go calling cmd.Execute()\n- Create cmd/root.go with root Cobra command\n- Create cmd/open.go with open subcommand\n- Ensure go build ./... and go vet ./... pass\n\n**Acceptance Criteria**:\n- [ ] go.mod exists with module path github.com/leeovery/portal\n- [ ] go.sum exists and Cobra + Bubble Tea are listed as dependencies\n- [ ] go build -o portal . produces a binary without errors\n- [ ] ./portal open prints a placeholder message and exits with code 0\n- [ ] ./portal --help shows usage including the open subcommand\n- [ ] go vet ./... reports no issues\n\n**Tests**:\n- root command executes without error\n- open subcommand is registered on root\n- open subcommand executes without error\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Architecture, CLI Interface, Dependencies sections.","parent":"tick-57d5a4","created":"2026-02-22T21:28:19Z","updated":"2026-02-23T13:03:53Z","closed":"2026-02-23T13:03:53Z"}
{"id":"tick-442b28","title":"tmux Session Listing and Parsing","status":"done","priority":2,"description":"**Problem**: Portal needs to query tmux for running sessions and parse the output into structured data. The tmux command may fail if no server is running.\n\n**Solution**: Create a tmux package with ListSessions() that runs tmux list-sessions -F '#{session_name}|#{session_windows}|#{session_attached}', parses each line into a Session struct. Handle no-server case by returning empty slice.\n\n**Outcome**: Tested tmux package with ListSessions() returning []Session with Name, Windows, Attached fields. Returns empty slice and nil error when no server running.\n\n**Do**:\n- Create internal/tmux/tmux.go with Session struct: Name string, Windows int, Attached bool\n- Define Commander interface with Run(args ...string) (string, error) for testability\n- Create Client struct with ListSessions() ([]Session, error)\n- Implement parsing: split by newlines, parse pipe-delimited fields\n- Handle non-zero exit (no server) -\u003e return empty slice, nil error\n- Create RealCommander using os/exec\n- Create internal/tmux/tmux_test.go with MockCommander\n\n**Acceptance Criteria**:\n- [ ] Session struct with Name, Windows, Attached fields\n- [ ] ListSessions() correctly parses multi-session output\n- [ ] Returns empty slice and nil error when tmux exits non-zero\n- [ ] Attached is true when session_attached \u003e 0\n- [ ] All tests pass\n\n**Tests**:\n- parses multiple sessions correctly\n- parses single session\n- returns empty slice when tmux server is not running\n- returns empty slice when output is empty\n- attached is true when session_attached \u003e 0\n- attached is false when session_attached is 0\n- handles session name with special characters\n\n**Edge Cases**:\n- No tmux server running: non-zero exit -\u003e empty slice, nil error\n- Empty session list: empty output -\u003e empty slice\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Session Info Display, Session Discovery, tmux Integration sections.","parent":"tick-57d5a4","created":"2026-02-22T21:28:33Z","updated":"2026-02-23T13:07:45Z","closed":"2026-02-23T13:07:45Z"}
{"id":"tick-afcc27","title":"Session List TUI Model","status":"done","priority":2,"description":"**Problem**: Portal needs a full-screen Bubble Tea TUI that displays running tmux sessions. The portal open command needs to launch a Bubble Tea program that fetches sessions and renders them with name, window count, and attached indicator.\n\n**Solution**: Create a Bubble Tea model in internal/tui/ that takes a tmux Client, calls ListSessions() on init, and renders a full-screen list. Wire portal open to launch with tea.NewProgram(model, tea.WithAltScreen()).\n\n**Outcome**: portal open launches full-screen TUI. Sessions appear in list with name, window count, attached indicator. First session highlighted by default. Sessions displayed in tmux list-sessions order (no additional sorting).\n\n**Do**:\n- Create internal/tui/model.go with Model struct: sessions []tmux.Session, cursor int, tmuxClient\n- Implement Init() returning command to fetch sessions\n- Define sessionsMsg type for async result\n- Implement Update() to handle sessionsMsg\n- Implement View() to render session list with cursor indicator, name, window count, attached indicator\n- Use Lip Gloss for styling\n- Update cmd/open.go to create Client, Model, and run tea.NewProgram\n- Create internal/tui/model_test.go\n- Preserve tmux list-sessions order; do not apply additional sorting\n\n**Acceptance Criteria**:\n- [ ] portal open launches full-screen alternate-screen TUI\n- [ ] Sessions appear with name, window count, attached indicator\n- [ ] Sessions displayed in tmux list-sessions order (no additional sorting)\n- [ ] Window count uses correct pluralisation (1 window vs N windows)\n- [ ] Attached sessions show indicator; detached do not\n- [ ] First session highlighted by default (cursor at 0)\n- [ ] All tests pass\n\n**Tests**:\n- view renders all session names\n- view shows window count for each session\n- view shows attached indicator\n- cursor starts at first session\n- single session renders correctly\n- long session name renders without truncation\n- sessions displayed in order returned by tmux (no sorting applied)\n\n**Edge Cases**:\n- Single session in list: must render correctly\n- Long session names: render fully, no truncation\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- TUI Design, Session Info Display, Sorting sections.","parent":"tick-57d5a4","created":"2026-02-22T21:28:49Z","updated":"2026-02-23T13:45:41Z","closed":"2026-02-23T13:45:41Z"}
{"id":"tick-27a6f2","title":"Keyboard Navigation","status":"done","priority":2,"description":"**Problem**: TUI renders a session list but does not respond to keyboard input for navigation. Users need to move cursor up/down using arrow keys and vim-style j/k keys.\n\n**Solution**: Add key message handling to Update function. Handle up/k (move up), down/j (move down). Clamp cursor to [0, len(sessions)-1].\n\n**Outcome**: Arrow keys and j/k move cursor through session list. Cursor clamps at boundaries (does not wrap). View reflects cursor position after each keypress.\n\n**Do**:\n- In internal/tui/model.go, extend Update to handle tea.KeyMsg\n- For KeyDown and 'j': increment cursor if cursor \u003c len(sessions)-1\n- For KeyUp and 'k': decrement cursor if cursor \u003e 0\n- Ensure cursor clamped: never \u003c 0, never \u003e len(sessions)-1\n- When len(sessions) == 0, navigation is no-op\n- Add tests in internal/tui/model_test.go\n\n**Acceptance Criteria**:\n- [ ] Down arrow or j moves cursor to next session\n- [ ] Up arrow or k moves cursor to previous session\n- [ ] Cursor does not go above first item\n- [ ] Cursor does not go below last item\n- [ ] View shows highlight on new cursor position\n- [ ] All tests pass\n\n**Tests**:\n- down arrow moves cursor down\n- j key moves cursor down\n- up arrow moves cursor up\n- k key moves cursor up\n- cursor does not go below last item\n- cursor does not go above first item\n- navigation is no-op with single session\n- view highlights correct row after navigation\n\n**Edge Cases**:\n- Single-item list: up/down are no-ops, cursor stays at 0\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Keyboard Shortcuts section.","parent":"tick-57d5a4","created":"2026-02-22T21:29:01Z","updated":"2026-02-23T13:55:27Z","closed":"2026-02-23T13:55:27Z"}
{"id":"tick-0f5439","title":"Quit Handling","status":"done","priority":2,"description":"**Problem**: TUI has no way to exit. Users need to quit cleanly with q or Esc.\n\n**Solution**: Add q and Esc key handling to Update. Return tea.Quit to cleanly exit and restore terminal state.\n\n**Outcome**: Pressing q or Esc exits program cleanly. Terminal restored to normal state. Process exits code 0.\n\n**Do**:\n- In internal/tui/model.go, extend Update to check for 'q' rune and tea.KeyEsc\n- When detected, return model and tea.Quit\n- Also handle tea.KeyCtrlC for robustness\n- Add tests in internal/tui/model_test.go\n\n**Acceptance Criteria**:\n- [ ] q exits TUI and returns to shell\n- [ ] Esc exits TUI and returns to shell\n- [ ] Ctrl+C exits TUI and returns to shell\n- [ ] Update returns tea.Quit when quit key pressed\n- [ ] Terminal state restored after quit\n- [ ] All tests pass\n\n**Tests**:\n- q key triggers quit\n- Esc key triggers quit\n- Ctrl+C triggers quit\n- navigation keys do not trigger quit\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Keyboard Shortcuts section.","parent":"tick-57d5a4","created":"2026-02-22T21:29:10Z","updated":"2026-02-23T13:58:30Z","closed":"2026-02-23T13:58:30Z"}
{"id":"tick-9776d9","title":"Attach on Enter","status":"done","priority":2,"description":"**Problem**: TUI displays and navigates sessions but Enter does nothing. The core flow -- selecting a session and attaching -- is missing.\n\n**Solution**: Handle Enter key in Update. Store selected session name, send tea.Quit, then after program exits call syscall.Exec to replace Portal process with tmux attach-session -t \u003cname\u003e.\n\n**Outcome**: Enter on highlighted session quits TUI and attaches to that tmux session via exec. Portal process replaced by tmux.\n\n**Do**:\n- In internal/tui/model.go, add selected string field\n- Handle tea.KeyEnter: if sessions loaded and cursor valid, set m.selected = m.sessions[m.cursor].Name, return tea.Quit\n- Add Selected() string method for caller to retrieve chosen session\n- In cmd/open.go, after tea.NewProgram().Run() returns, check model.Selected()\n- If non-empty, call syscall.Exec with tmux attach-session -t \u003cname\u003e\n- Use exec.LookPath(\"tmux\") to find binary path for syscall.Exec (required to get absolute path)\n- If LookPath fails, return error (centralised tmux dependency check is added in Phase 6, task portal-6-6)\n- If Selected() empty (user quit), exit cleanly with code 0\n- Add tests in internal/tui/model_test.go\n\n**Acceptance Criteria**:\n- [ ] Enter sets selected session and triggers tea.Quit\n- [ ] After TUI exits, syscall.Exec invoked with tmux attach-session -t \u003cname\u003e\n- [ ] Portal process replaced by tmux (exec, not subprocess)\n- [ ] Quitting without selecting does not trigger attach\n- [ ] Enter with zero sessions is no-op\n- [ ] All tests pass\n\n**Tests**:\n- Enter sets selected session and triggers quit\n- Enter with no sessions is a no-op\n- quit without selecting leaves selected empty\n- selected returns correct session after navigation and Enter\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Keyboard Shortcuts, Running Inside tmux, Process Handoff, tmux Integration sections.","parent":"tick-57d5a4","created":"2026-02-22T21:29:24Z","updated":"2026-02-23T14:03:28Z","closed":"2026-02-23T14:03:28Z"}
{"id":"tick-e70af4","title":"Empty State Display","status":"done","priority":2,"description":"**Problem**: When no tmux sessions exist, TUI shows empty list with no indication. User needs clear message: \"No active sessions\".\n\n**Solution**: In View(), check if sessions loaded (via loaded bool flag) and slice empty. When both true, render \"No active sessions\" instead of session list.\n\n**Outcome**: When portal open runs with no sessions, TUI displays \"No active sessions\". User can still quit with q/Esc.\n\n**Do**:\n- In internal/tui/model.go, add loaded bool field, initially false\n- In Update, when handling sessionsMsg, set m.loaded = true\n- In View, if m.loaded \u0026\u0026 len(m.sessions) == 0, render \"No active sessions\"\n- Quit keys still work in empty state\n- Navigation and Enter are no-ops in empty state (already handled)\n- Add tests in internal/tui/model_test.go\n\n**Acceptance Criteria**:\n- [ ] No sessions displays \"No active sessions\"\n- [ ] No tmux server (empty slice returned) displays \"No active sessions\"\n- [ ] Empty state message appears only after sessions fetched\n- [ ] Quit keys work in empty state\n- [ ] All tests pass\n\n**Tests**:\n- empty sessions shows no active sessions message\n- non-empty sessions does not show empty message\n- empty state is not shown before sessions are loaded\n- quit works in empty state\n- Enter is no-op in empty state\n\n**Edge Cases**:\n- tmux server disappears between list and display: handled at attach layer (tmux reports error)\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Empty States, Session Discovery sections.","parent":"tick-57d5a4","created":"2026-02-22T21:29:36Z","updated":"2026-02-23T14:07:10Z","closed":"2026-02-23T14:07:10Z"}
{"id":"tick-a8f83d","title":"Phase 2: New Session from Directory -- Project Memory and Session Creation","status":"open","priority":2,"parent":"tick-77cbba","created":"2026-02-22T21:45:35Z","updated":"2026-02-22T21:45:35Z"}
{"id":"tick-2bb2d0","title":"Git Root Resolution","status":"open","priority":2,"description":"**Problem**: When a directory is selected for a new session, Portal must resolve it to the git repository root. Non-git directories used as-is.\n\n**Solution**: Implement ResolveGitRoot function using git -C \u003cdir\u003e rev-parse --show-toplevel. Return original dir on failure. Use CommandRunner interface for testability.\n\n**Outcome**: Tested, reusable function that resolves any directory to its git root or returns unchanged for non-git directories.\n\n**Do**:\n- Create internal/resolver/gitroot.go with ResolveGitRoot(dir string) (string, error)\n- Use exec.Command for git command\n- On success (exit 0), return trimmed stdout\n- On failure (any non-zero exit), return original dir unchanged with no error\n- Check directory existence before running git\n- Accept CommandRunner interface for testing\n\n**Acceptance Criteria**:\n- [ ] ResolveGitRoot returns git root for subdirectory of git repo\n- [ ] ResolveGitRoot returns original dir for non-git directory\n- [ ] ResolveGitRoot returns original dir when git not installed\n- [ ] No user-facing output during resolution\n\n**Tests**:\n- resolves subdirectory to git repository root\n- returns original directory for non-git directory\n- returns original directory when git is not installed\n- trims whitespace from git output\n- returns error when directory does not exist\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Git Root Resolution section","parent":"tick-a8f83d","created":"2026-02-22T21:45:47Z","updated":"2026-02-22T21:45:47Z"}
{"id":"tick-4ebf36","title":"Session Name Generation","status":"open","priority":2,"description":"**Problem**: Portal needs to auto-generate unique tmux session names in format {project-name}-{nanoid}. Project name must be sanitised (no periods or colons), and collisions must be handled.\n\n**Solution**: Implement GenerateSessionName function that sanitises name, appends 6-char nanoid, checks for collisions, retries up to 10 times.\n\n**Outcome**: Tested session name generation that produces sanitised, unique names in {project}-{nanoid} format with collision retry.\n\n**Do**:\n- Create internal/session/naming.go\n- SanitiseProjectName: replace . and : with -\n- GenerateSessionName(projectName, exists func) returns unique name\n- Injectable nanoid generator for testing\n\n**Acceptance Criteria**:\n- [ ] Returns name matching pattern {project}-[a-zA-Z0-9]{6}\n- [ ] Periods replaced with hyphens\n- [ ] Colons replaced with hyphens\n- [ ] Retries on collision\n- [ ] Error after max retries\n\n**Tests**:\n- generates name in correct format\n- sanitises periods/colons\n- retries on collision\n- returns error after max retries\n- handles empty project name\n\n**Edge Cases**:\n- Empty project name: produces -{nanoid} format (or error, to be decided)\n- Max collision retries exhausted: returns descriptive error\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Session Naming section","parent":"tick-a8f83d","created":"2026-02-22T21:45:56Z","updated":"2026-02-23T11:29:58Z"}
{"id":"tick-248cf4","title":"Project Store (projects.json)","status":"open","priority":2,"description":"**Problem**: Portal needs to persist remembered project directories in projects.json at ~/.config/portal/.\n\n**Solution**: Implement ProjectStore with CRUD operations. Load handles missing/malformed files gracefully. Save uses atomic writes. Upsert by path. List sorted by last_used.\n\n**Outcome**: Tested ProjectStore with Load, Save, Upsert, List, and Remove operations persisting projects to ~/.config/portal/projects.json with graceful handling of missing/malformed files.\n\n**Do**:\n- Create internal/project/store.go\n- Project struct: Path, Name, LastUsed\n- Load(): handle missing file, malformed JSON\n- Save(): create dir, atomic write (temp+rename)\n- Upsert(path, name): add/update project\n- List(): sorted by last_used descending\n- Remove(path): delete entry\n\n**Acceptance Criteria**:\n- [ ] Load returns empty list when file missing\n- [ ] Load returns empty list for malformed JSON\n- [ ] Save creates config directory\n- [ ] Upsert adds new or updates existing\n- [ ] List sorted by last_used descending\n\n**Tests**:\n- loads empty list when file does not exist\n- loads projects from valid JSON\n- handles malformed JSON\n- creates config directory on save\n- upsert adds/updates project\n- list returns sorted projects\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Configuration \u0026 Storage, projects.json Structure","parent":"tick-a8f83d","created":"2026-02-22T21:46:06Z","updated":"2026-02-23T11:30:06Z"}
{"id":"tick-275824","title":"Stale Project Cleanup","status":"open","priority":2,"description":"**Problem**: Project directories can be deleted after being remembered. Stale projects should be automatically removed when project picker is displayed.\n\n**Solution**: Implement CleanStale() method on ProjectStore. Check each directory with os.Stat, remove non-existent ones, retain permission-denied dirs.\n\n**Outcome**: CleanStale() removes projects with non-existent directories, retains those with permission errors, and returns the count of removed entries.\n\n**Do**:\n- Add CleanStale() (int, error) to ProjectStore\n- Iterate projects, os.Stat each path\n- If os.IsNotExist, mark for removal\n- If permission error, keep the project\n- Save only if changes made\n- Return count of removed\n\n**Acceptance Criteria**:\n- [ ] Removes projects with non-existent directories\n- [ ] Retains projects with existing directories\n- [ ] Retains projects with permission denied\n- [ ] Returns 0 when no stale projects\n\n**Tests**:\n- removes project with non-existent directory\n- retains project with existing directory\n- retains project with permission denied\n- returns zero on empty list\n- removes multiple stale in single call\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Stale Project Cleanup section","parent":"tick-a8f83d","created":"2026-02-22T21:46:15Z","updated":"2026-02-23T11:30:13Z"}
{"id":"tick-f924e3","title":"Session Creation from Project","status":"open","priority":2,"description":"**Problem**: Portal needs to create a new tmux session from a project directory, orchestrating git root resolution, name generation, project store update, and tmux command.\n\n**Solution**: Implement SessionCreator.CreateFromDir that coordinates the full flow: resolve git root, derive project name, generate session name, upsert project, create tmux session.\n\n**Outcome**: SessionCreator.CreateFromDir creates a tmux session with auto-generated name in the git-root-resolved directory, registers/updates the project in store, and returns the session name for handoff.\n\n**Do**:\n- Create internal/session/create.go\n- SessionCreator struct with dependencies: GitResolver, ProjectStore, TmuxClient\n- CreateFromDir(dir): resolve git root, derive name from basename, generate session name, upsert project, call tmux NewSession\n- Extend TmuxClient: HasSession(name) bool, NewSession(name, dir) error\n- Validate directory exists before tmux call\n\n**Acceptance Criteria**:\n- [ ] Resolves directory to git root\n- [ ] Generates session name from basename with nanoid\n- [ ] Upserts project in store\n- [ ] Creates tmux session with correct name and dir\n- [ ] Works when no tmux server running\n- [ ] Returns error when directory missing\n\n**Tests**:\n- creates session with git-root-resolved directory\n- derives project name from basename\n- generates unique session name\n- upserts project in store\n- handles tmux server not running\n- returns error for non-existent directory\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- New Session Flow, How Directories are Added","parent":"tick-a8f83d","created":"2026-02-22T21:46:25Z","updated":"2026-02-23T11:38:20Z"}
{"id":"tick-4c54e1","title":"Project Picker TUI View","status":"open","priority":2,"description":"**Problem**: Portal needs a project picker TUI showing remembered projects sorted by recency with browse option at bottom and empty state handling.\n\n**Solution**: Implement ProjectPickerModel as Bubble Tea component. Display projects from store, always show browse option, handle empty state. Support filter mode via / key.\n\n**Outcome**: Project picker TUI displays remembered projects sorted by last_used, browse option always visible, filter mode via /, and handles empty state gracefully.\n\n**Do**:\n- Create internal/ui/projectpicker.go with ProjectPickerModel\n- Init: call store.CleanStale(), store.List()\n- Render: header, project list with cursor, separator, browse option\n- Navigation: Up/Down/j/k, Enter selects, Esc returns\n- Empty state: \"No saved projects yet.\" with browse still visible\n- Return selection message (project path or browse action)\n- / key activates filter mode with fuzzy matching against project names\n- Filter mode: browse option always visible, Backspace/Esc behavior\n\n**Acceptance Criteria**:\n- [ ] Displays projects sorted by last_used\n- [ ] browse option always visible at bottom\n- [ ] Arrow keys and j/k navigate list\n- [ ] Enter on project returns selection\n- [ ] Enter on browse returns browse action\n- [ ] Esc returns to session list\n- [ ] Empty state with browse still selectable\n- [ ] / activates filter mode; typing fuzzy-matches against project names\n- [ ] Filter mode: [n]/browse option always visible regardless of filter\n- [ ] Filter mode: Backspace removes last char; on empty filter exits filter mode\n- [ ] Filter mode: Esc clears filter and exits filter mode\n\n**Tests**:\n- displays projects sorted by last_used\n- shows browse option at bottom\n- empty state shows message\n- enter on project emits path\n- esc emits back message\n- slash activates filter mode in project picker\n- typing narrows project list by fuzzy match\n- browse option always visible during filter\n- backspace on empty filter exits filter mode\n- esc clears filter and exits filter mode\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Project Picker Interaction, Empty States","parent":"tick-a8f83d","created":"2026-02-22T21:46:36Z","updated":"2026-02-23T11:38:24Z"}
{"id":"tick-444a76","title":"Main TUI New in Project Integration","status":"open","priority":2,"description":"**Problem**: Main session list needs [n] new in project... option that transitions to project picker. After selection, create session and attach.\n\n**Solution**: Extend Phase 1 session list with new option below divider, wire n shortcut, implement view switching between session list and project picker.\n\n**Outcome**: Main TUI shows [n] new in project... option below sessions, transitions to project picker on select, creates session from selected project, and handles navigation back to session list.\n\n**Do**:\n- Add [n] new in project... option below sessions with divider\n- n shortcut jumps to the option\n- View states: viewSessionList, viewProjectPicker\n- Enter on option switches to project picker\n- Esc in picker returns to session list\n- Project selection triggers SessionCreator.CreateFromDir then tmux exec\n- Browse action is placeholder for Phase 3\n\n**Acceptance Criteria**:\n- [ ] [n] new in project... appears below sessions with divider\n- [ ] n key jumps to new option\n- [ ] Enter on option transitions to project picker\n- [ ] Selecting project creates session and attaches\n- [ ] Esc in picker returns to session list\n- [ ] Empty session list still shows option\n- [ ] Combined empty state (no sessions + no projects) navigable\n\n**Tests**:\n- session list includes new in project option\n- n key jumps to option\n- enter switches to project picker\n- esc returns to session list\n- project selection triggers creation\n- empty session list shows option\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- TUI Design, Keyboard Shortcuts","parent":"tick-a8f83d","created":"2026-02-22T21:46:49Z","updated":"2026-02-23T11:38:28Z"}
{"id":"tick-f6e9a1","title":"Phase 3: File Browser and CLI Quick-Start","status":"open","priority":2,"parent":"tick-77cbba","created":"2026-02-22T21:59:41Z","updated":"2026-02-22T21:59:41Z"}
{"id":"tick-f26ed6","title":"Directory Listing Model","status":"open","priority":2,"description":"**Problem**: The file browser needs a directory listing function that returns only directories, with optional hidden directory filtering. This is the data layer for the file browser TUI.\n\n**Solution**: Implement ListDirectories(path, showHidden) returning a sorted slice of directory entries. Files are excluded. Hidden directories (starting with `.`) are excluded unless showHidden is true.\n\n**Outcome**: Tested function returning directory-only entries, handling empty dirs, permission denied, and symlinks gracefully.\n\n**Do**:\n- Create internal/browser/listing.go with DirEntry struct (Name string, IsSymlink bool)\n- ListDirectories(path string, showHidden bool) ([]DirEntry, error)\n- Read directory entries via os.ReadDir, filter to directories only (files not displayed per spec)\n- Exclude entries starting with `.` when showHidden is false\n- Sort entries alphabetically by name\n- Return empty slice (not error) on permission denied\n- Follow symlinks to check if target is a directory\n\n**Acceptance Criteria**:\n- [ ] Returns only directory entries, no files\n- [ ] Hidden directories excluded when showHidden is false\n- [ ] Hidden directories included when showHidden is true\n- [ ] Entries sorted alphabetically\n- [ ] Returns empty slice on permission denied\n- [ ] Symlinked directories included; symlinked files excluded\n- [ ] Returns empty slice for empty directory\n\n**Tests**:\n- returns only directories\n- excludes hidden when showHidden=false\n- includes hidden when showHidden=true\n- returns empty for empty directory\n- handles permission denied gracefully\n- sorts entries alphabetically\n- includes symlinked directories\n- excludes symlinked files\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- File Browser (Content: shows directories only)","parent":"tick-f6e9a1","created":"2026-02-22T21:59:48Z","updated":"2026-02-23T11:17:08Z"}
{"id":"tick-62c4f1","title":"File Browser TUI -- Core Navigation","status":"open","priority":2,"description":"**Problem**: Portal needs an interactive file browser TUI for navigating the filesystem to select a directory for new session creation. The browser must support descending into directories, ascending to parent, and showing a `.` entry to select the current directory.\n\n**Solution**: Implement a Bubble Tea FileBrowserModel that starts at the current working directory, renders the directory listing with cursor navigation, and supports Enter/right-arrow to descend and Backspace/left-arrow to ascend.\n\n**Outcome**: Interactive file browser TUI with directory navigation. Enter/right descends, Backspace/left ascends, `.` entry at top represents current directory. Navigation stops at root.\n\n**Do**:\n- Create internal/ui/browser.go with FileBrowserModel struct\n- Init with starting path set to current working directory (per spec: \"Starting directory: Current working directory\")\n- Render: current path header, `.` entry at top (current dir indicator), then directory listing with cursor\n- Enter or right-arrow on a directory: descend into it, refresh listing\n- Backspace or left-arrow: go to parent directory; no-op at filesystem root\n- Up/Down and j/k: navigate the listing\n- Cursor resets to 0 when entering a new directory\n\n**Acceptance Criteria**:\n- [ ] Browser starts at current working directory\n- [ ] Current path displayed as header\n- [ ] `.` entry shown at top of listing\n- [ ] Enter on directory descends into it\n- [ ] Right-arrow on directory descends into it\n- [ ] Backspace goes to parent directory\n- [ ] Left-arrow goes to parent directory\n- [ ] Navigation is no-op at filesystem root\n- [ ] Up/Down and j/k navigate listing\n- [ ] Cursor resets when entering subdirectory\n\n**Tests**:\n- displays current path\n- shows dot entry at top\n- enter descends into directory\n- right arrow descends into directory\n- backspace goes to parent\n- left arrow goes to parent\n- no-op at root directory\n- cursor navigation works\n- cursor resets on directory change\n- starts at cwd\n\n**Edge Cases**:\n- Root directory: Backspace/left-arrow are no-ops\n- Single subdirectory: cursor stays at 0\n- Deeply nested path: header shows full path\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- File Browser (Behavior) section","parent":"tick-f6e9a1","created":"2026-02-22T21:59:55Z","updated":"2026-02-23T11:17:23Z"}
{"id":"tick-cebbcb","title":"File Browser Inline Filter","status":"open","priority":2,"description":"**Problem**: The file browser needs inline filtering so users can quickly narrow the directory listing by typing. The spec defines dual-purpose Backspace (filter char removal or parent navigation) and dual-purpose Esc (clear filter or cancel browser).\n\n**Solution**: Add filter state to the browser model. Typing narrows visible entries by fuzzy match at the current directory level. Backspace removes the last filter character; when filter is empty, Backspace reverts to navigation (go to parent). Esc clears active filter; if no filter is active, Esc cancels the browser.\n\n**Outcome**: Typing fuzzy-filters directory listing. Backspace and Esc have context-sensitive behavior based on filter state.\n\n**Do**:\n- Add filterText string to FileBrowserModel\n- Rune keypresses: append to filterText, recompute visible entries by fuzzy match\n- Backspace: if filterText non-empty, remove last char and re-filter; if filterText empty, go to parent directory\n- Esc: if filterText non-empty, clear filterText and show full listing; if filterText empty, cancel browser (emit cancel message)\n- Filter resets (filterText = \"\") when entering a subdirectory via Enter/right-arrow\n- Cursor resets to 0 when filter changes\n\n**Acceptance Criteria**:\n- [ ] Typing narrows directory listing by fuzzy match\n- [ ] Backspace removes last filter character when filter active\n- [ ] Backspace goes to parent when filter is empty\n- [ ] Esc clears filter when filter is active\n- [ ] Esc cancels browser when no filter is active\n- [ ] Filter resets when entering a subdirectory\n- [ ] Cursor resets when filter changes\n\n**Tests**:\n- typing filters directory listing\n- backspace removes filter char\n- backspace on empty filter goes to parent\n- esc clears active filter\n- esc cancels browser when no filter\n- filter resets on directory change\n- cursor resets on filter change\n- filter matches nothing shows empty listing\n\n**Edge Cases**:\n- Filter matches nothing: empty listing shown, no directories selectable\n- Filter then navigate to child: filter resets\n- All characters deleted via Backspace: filter empty, full listing restored\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- File Browser (Filtering) section","parent":"tick-f6e9a1","created":"2026-02-22T22:00:03Z","updated":"2026-02-23T11:17:34Z"}
{"id":"tick-feea91","title":"File Browser Hidden Directory Toggle and Selection","status":"open","priority":2,"description":"**Problem**: The file browser needs two additional features: toggling hidden directory visibility and selecting the current directory for session creation. Hidden directories (`.` prefix) are hidden by default and toggled with the `.` key. The current directory is selected via Space or Enter on the `.` entry.\n\n**Solution**: Add a showHidden toggle activated by the `.` key (only outside filter mode to avoid conflict with typing). Space or Enter on the `.` entry at the top of the listing selects the current directory, emitting a selection message. The toggle is session-scoped (resets on next browser open).\n\n**Outcome**: `.` key toggles hidden directory visibility. Space/Enter on `.` entry selects current directory for session creation.\n\n**Do**:\n- `.` key toggles showHidden flag and refreshes listing (only when not in filter mode, to avoid conflict with typing `.` as filter text)\n- Space on `.` entry: emit selection message with current directory path\n- Enter on `.` entry: same behavior as Space\n- Validate directory still exists before emitting selection\n- Selection message carries the path for downstream processing (git root resolution, project registration, session creation)\n- Toggle applies only to current browser session; resets on next open\n\n**Acceptance Criteria**:\n- [ ] `.` key toggles hidden directory visibility\n- [ ] Hidden directories shown after toggle\n- [ ] Hidden directories hidden again after second toggle\n- [ ] Space on `.` entry emits directory selection\n- [ ] Enter on `.` entry emits directory selection\n- [ ] Selection message contains current directory path\n- [ ] `.` key ignored when filter is active\n- [ ] Toggle resets on next browser open\n- [ ] Selected directory auto-added to projects.json (via integration)\n\n**Tests**:\n- dot key toggles hidden visibility\n- space on dot entry emits selection\n- enter on dot entry emits selection\n- selection message contains current path\n- dot key ignored when filtering\n- directory has only hidden subdirectories and toggle reveals them\n- selected directory removed between browse and select produces error\n\n**Edge Cases**:\n- Directory has only hidden subdirectories: listing appears empty until `.` toggle\n- Selected directory removed between browse and select: error at selection time\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- File Browser (Hidden directories, Select current directory) section","parent":"tick-f6e9a1","created":"2026-02-22T22:00:09Z","updated":"2026-02-23T11:17:44Z"}
{"id":"tick-9d6404","title":"File Browser Integration with Project Picker","status":"open","priority":2,"description":"**Problem**: The file browser must be wired into the project picker flow. When the user selects \"browse for directory...\" in the project picker, the file browser opens. A directory selection flows through git root resolution, project registration, and session creation. Cancelling returns to the project picker.\n\n**Solution**: Connect the project picker's browse option to the file browser. On selection, resolve git root, register the project in projects.json, create the tmux session, and exec/switch. On cancel (Esc with no filter), return to the project picker view.\n\n**Outcome**: End-to-end flow from project picker browse option through file browser to session creation. Cancel returns to project picker.\n\n**Do**:\n- In project picker: Enter on browse option transitions to file browser view\n- File browser selection: resolve directory to git root, upsert project in store, create session (reuse Phase 2 SessionCreator)\n- File browser cancel (Esc with no filter): transition back to project picker view\n- Works from empty project list (browse is the only selectable option)\n\n**Acceptance Criteria**:\n- [ ] Browse option in project picker opens file browser\n- [ ] Selected directory resolved to git root before session creation\n- [ ] Selected directory registered in projects.json\n- [ ] Session created with auto-generated name and resolved directory\n- [ ] Cancel in browser returns to project picker\n- [ ] Browse works from empty project list (only browse option available)\n\n**Tests**:\n- browse option opens file browser\n- selection creates session with git-root-resolved path\n- selection registers project in store\n- cancel returns to project picker\n- browse works from empty project list\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- File Browser (Access, Behavior), Project Memory (How Directories are Added)","parent":"tick-f6e9a1","created":"2026-02-22T22:00:17Z","updated":"2026-02-23T11:17:58Z"}
{"id":"tick-33fb7f","title":"CLI Quick-Start Path Resolution","status":"open","priority":2,"description":"**Problem**: Portal needs non-interactive quick-start paths (`portal open .` and `portal open \u003cpath\u003e`) that resolve a directory and create a session without launching the TUI. Paths must be validated, expanded, and resolved.\n\n**Solution**: Implement ResolvePath for tilde expansion and relative-to-absolute conversion. Implement IsPathArgument to detect path-like arguments. Wire into `portal open`: if the argument is a path, resolve it and skip the TUI. Validate the resolved path exists and is a directory.\n\n**Outcome**: `portal open .` resolves cwd, `portal open \u003cpath\u003e` resolves the given path. Non-existent paths print error and exit 1. No TUI is launched.\n\n**Do**:\n- Create internal/resolver/path.go with ResolvePath(arg string) (string, error)\n- Expand `~` to user home directory\n- Resolve relative paths to absolute using filepath.Abs\n- Validate path exists (os.Stat); if not, return error with \"Directory not found: {path}\"\n- Validate path is a directory (not a file); if file, return error\n- IsPathArgument(arg string) bool: true if arg contains `/` or starts with `.` or `~`\n- Wire into cmd/open.go: check IsPathArgument; if true, call ResolvePath and skip TUI, proceed to session creation\n\n**Acceptance Criteria**:\n- [ ] `portal open .` resolves current working directory\n- [ ] `portal open \u003crelative-path\u003e` resolves to absolute path\n- [ ] `portal open ~/path` expands tilde to home directory\n- [ ] Non-existent path prints \"Directory not found: {path}\" and exits with code 1\n- [ ] Path that is a file (not directory) prints error and exits with code 1\n- [ ] TUI is not launched for path arguments\n\n**Tests**:\n- resolves relative path to absolute\n- expands tilde to home directory\n- returns error for non-existent path\n- returns error when path is a file\n- portal open . resolves cwd\n- IsPathArgument true for paths with /\n- IsPathArgument true for paths starting with .\n- IsPathArgument true for paths starting with ~\n- IsPathArgument false for plain words\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- x (The Launcher, Quick-start shortcuts), Query Resolution (Path detection heuristic, Path validation)","parent":"tick-f6e9a1","created":"2026-02-22T22:00:25Z","updated":"2026-02-23T11:18:09Z"}
{"id":"tick-afb187","title":"CLI Quick-Start Session Creation","status":"open","priority":2,"description":"**Problem**: After path resolution, Portal must orchestrate the full session creation flow: git root resolution, project registration, session name generation, tmux session creation, and process handoff. This wires the CLI quick-start paths through the existing Phase 2 primitives.\n\n**Solution**: Implement a QuickStart function that takes a resolved path and executes the full creation pipeline. Reuse GitResolver, ProjectStore, and SessionCreator from Phase 2. Update last_used if the project already exists in the store.\n\n**Outcome**: `portal open .` and `portal open \u003cpath\u003e` create a tmux session in the resolved directory with git root resolution, project registration, and exec handoff.\n\n**Do**:\n- Implement QuickStart(path string) in cmd/open.go or internal/session/\n- Steps: resolve git root -\u003e derive project name from basename -\u003e upsert project (add or update last_used) -\u003e generate session name -\u003e tmux new-session -A -s \u003cname\u003e -c \u003cdir\u003e -\u003e exec handoff\n- Reuse Phase 2 primitives: GitResolver, ProjectStore.Upsert, SessionCreator\n- Update last_used timestamp if project already exists in projects.json\n- Exec handoff replaces Portal process with tmux (same as TUI attach path)\n\n**Acceptance Criteria**:\n- [ ] Resolved path goes through git root resolution\n- [ ] New project registered in projects.json with name from directory basename\n- [ ] Existing project's last_used timestamp updated\n- [ ] Session name auto-generated ({project}-{nanoid})\n- [ ] tmux session created with resolved directory via -c flag\n- [ ] Portal process replaced by tmux via exec\n\n**Tests**:\n- creates session with git-root-resolved directory\n- registers new project in store\n- updates last_used for existing project\n- exec replaces process with tmux\n- session name follows {project}-{nanoid} format\n- project name derived from directory basename after git root resolution\n\n**Edge Cases**:\n- cwd is inside git repo subdirectory: resolved to git root, project name from root basename\n- Project already in projects.json: last_used updated, no duplicate entry\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Directory Change for New Sessions, Git Root Resolution, How Directories are Added, Session Naming, Process Handoff","parent":"tick-f6e9a1","created":"2026-02-22T22:00:31Z","updated":"2026-02-23T11:18:21Z"}
{"id":"tick-0c342f","title":"Phase 4: Query Resolution, Aliases, and Shell Integration","status":"open","priority":2,"parent":"tick-77cbba","created":"2026-02-22T22:06:48Z","updated":"2026-02-22T22:06:48Z"}
{"id":"tick-5533b4","title":"Alias Store","status":"open","priority":2,"description":"**Problem**: Portal needs persistent alias storage in a flat key=value file at ~/.config/portal/aliases. Aliases map short names to directory paths for quick navigation.\n\n**Solution**: Implement AliasStore with Load/Save/Get/Set/Delete/List operations managing the aliases file. Handle missing file, missing config directory, empty file, and duplicate keys gracefully.\n\n**Outcome**: Tested AliasStore that reads and writes ~/.config/portal/aliases in flat key=value format with full CRUD operations.\n\n**Do**:\n- Create internal/alias/store.go with AliasStore struct\n- File format: one alias per line, `name=path` (e.g., `m2api=/Users/lee/Code/mac2/api`)\n- Load(): read file, parse lines, handle missing file (return empty), handle empty file (return empty), handle duplicate keys (last wins)\n- Save(): create config directory if needed, write all aliases to file\n- Get(name string) (string, bool): return path for alias name\n- Set(name, path string): add or overwrite alias (aliases must be unique per spec)\n- Delete(name string) bool: remove alias, return whether it existed\n- List() []Alias: return all aliases sorted by name\n\n**Acceptance Criteria**:\n- [ ] Load returns empty map when file does not exist\n- [ ] Load returns empty map for empty file\n- [ ] Load handles duplicate keys (last value wins)\n- [ ] Save creates ~/.config/portal/ directory if needed\n- [ ] Set adds new alias\n- [ ] Set overwrites existing alias (uniqueness enforced)\n- [ ] Delete removes alias and returns true; returns false if not found\n- [ ] List returns all aliases sorted by name\n- [ ] File format is flat key=value, one per line\n\n**Tests**:\n- loads empty map when file does not exist\n- loads aliases from valid file\n- handles duplicate keys (last wins)\n- creates config directory on save\n- set adds new alias\n- set overwrites existing alias\n- delete removes existing alias\n- delete returns false for non-existent alias\n- list returns sorted aliases\n- handles empty file\n\n**Context**:\n\u003e Per spec: \"Aliases are stored separately from projects in ~/.config/portal/aliases, using a flat key-value format.\" Aliases must be unique -- each name maps to exactly one path.\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Alias Storage section","parent":"tick-0c342f","created":"2026-02-22T22:06:57Z","updated":"2026-02-23T11:18:49Z"}
{"id":"tick-a2e7bd","title":"Alias Set Command with Path Normalisation","status":"open","priority":2,"description":"**Problem**: Portal needs a `portal alias set \u003cname\u003e \u003cpath\u003e` CLI command that stores an alias with path normalization. Paths must have tilde expanded and relative paths resolved to absolute before storage.\n\n**Solution**: Implement the Cobra command for `portal alias set`. Normalize the path (expand `~`, resolve relative to absolute) before storing via AliasStore. The aliases file always contains absolute paths per spec.\n\n**Outcome**: `portal alias set m2api ~/Code/mac2/api` stores the alias with the fully resolved absolute path.\n\n**Do**:\n- Create cmd/alias.go with `portal alias` parent command and `portal alias set` subcommand\n- Accept exactly two positional arguments: name and path\n- NormalisePath(path string) string: expand `~` to os.UserHomeDir(), resolve relative paths to absolute via filepath.Abs()\n- Call AliasStore.Set(name, normalisedPath)\n- Save the aliases file after setting\n- If overwriting an existing alias, do so silently (spec: setting existing alias overwrites)\n\n**Acceptance Criteria**:\n- [ ] `portal alias set \u003cname\u003e \u003cpath\u003e` stores alias\n- [ ] Tilde expanded to home directory before storage\n- [ ] Relative paths resolved to absolute before storage\n- [ ] Aliases file always contains absolute paths\n- [ ] Setting existing alias overwrites silently\n- [ ] Exit 0 on success\n\n**Tests**:\n- sets new alias with absolute path\n- expands tilde in path\n- resolves relative path to absolute\n- overwrites existing alias silently\n- aliases file contains absolute path after set\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Alias Storage (Path normalization), xctl alias commands","parent":"tick-0c342f","created":"2026-02-22T22:06:58Z","updated":"2026-02-23T11:18:57Z"}
{"id":"tick-26cdeb","title":"Alias Remove and List Commands","status":"open","priority":2,"description":"**Problem**: Portal needs `portal alias rm \u003cname\u003e` and `portal alias list` CLI commands for alias management.\n\n**Solution**: Implement Cobra subcommands for alias removal and listing. Remove prints error and exits 1 if alias not found. List outputs all aliases sorted; empty output when none.\n\n**Outcome**: Complete alias management CLI: set, remove, and list operations.\n\n**Do**:\n- Add `portal alias rm` subcommand: accept one positional argument (name)\n- If alias not found, print error to stderr and exit 1\n- If alias found, delete and save; exit 0\n- Add `portal alias list` subcommand: no arguments\n- List all aliases in format `name=path`, sorted by name\n- Empty output (nothing printed) when no aliases exist; exit 0\n\n**Acceptance Criteria**:\n- [ ] `portal alias rm \u003cname\u003e` removes alias and exits 0\n- [ ] `portal alias rm \u003cname\u003e` prints error and exits 1 when alias not found\n- [ ] `portal alias list` outputs all aliases sorted by name\n- [ ] `portal alias list` produces empty output when no aliases\n- [ ] Both commands exit 0 on success\n\n**Tests**:\n- rm removes existing alias\n- rm prints error for non-existent alias\n- rm exits 1 for non-existent alias\n- list outputs aliases sorted by name\n- list produces empty output when no aliases\n- list exits 0\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- xctl alias commands, Alias Storage","parent":"tick-0c342f","created":"2026-02-22T22:06:59Z","updated":"2026-02-23T11:19:03Z"}
{"id":"tick-b3b992","title":"Zoxide Query Integration","status":"open","priority":2,"description":"**Problem**: Portal needs zoxide integration as an optional step in query resolution. Zoxide provides frecency-based directory matching but may not be installed.\n\n**Solution**: Implement ZoxideResolver that wraps `zoxide query \u003cterms\u003e`. Return the best match on success. Use sentinel errors for \"not installed\" and \"no match\" conditions. Skip silently when zoxide is not installed.\n\n**Outcome**: Tested zoxide integration that resolves queries via frecency, with graceful degradation when zoxide is absent.\n\n**Do**:\n- Create internal/resolver/zoxide.go with ZoxideResolver struct\n- Query(terms string) (string, error): run `zoxide query \u003cterms\u003e`, return trimmed stdout on exit 0\n- Use exec.LookPath(\"zoxide\") to check availability before running\n- If LookPath fails: return \"\", ErrZoxideNotInstalled (caller skips silently)\n- If zoxide exits non-zero (no match): return \"\", ErrNoMatch\n- Define sentinel errors: ErrZoxideNotInstalled, ErrNoMatch\n\n**Acceptance Criteria**:\n- [ ] Returns best zoxide match on success\n- [ ] Returns ErrZoxideNotInstalled when zoxide not on PATH\n- [ ] Returns ErrNoMatch when zoxide finds no match\n- [ ] Caller can skip silently on ErrZoxideNotInstalled\n- [ ] Output trimmed of whitespace\n\n**Tests**:\n- returns best match from zoxide query\n- returns ErrZoxideNotInstalled when zoxide not installed\n- returns ErrNoMatch when zoxide returns no match\n- trims whitespace from zoxide output\n- handles multi-word query terms\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Query Resolution (Zoxide query step), Dependencies (Zoxide is optional soft dependency)","parent":"tick-0c342f","created":"2026-02-22T22:07:00Z","updated":"2026-02-23T11:19:17Z"}
{"id":"tick-fe7c90","title":"Query Resolution Chain","status":"open","priority":2,"description":"**Problem**: Portal needs a unified query resolution chain for `portal open \u003cquery\u003e`. The argument must be resolved through a priority chain: path detection, alias lookup, zoxide query, then TUI fallback. After resolution, the directory must be validated.\n\n**Solution**: Implement QueryResolver that applies the resolution chain in order. Path detection uses a heuristic: arguments containing `/` or starting with `.` or `~` are treated as paths. Non-path arguments check alias store, then zoxide, then fall back to TUI with the query pre-filled as filter text.\n\n**Outcome**: `portal open \u003cquery\u003e` resolves through the full chain. Resolved directories are validated. Unresolved queries fall back to the TUI with the query pre-filled as filter text in the session list (or project picker if command pending).\n\n**Do**:\n- Create internal/resolver/query.go with QueryResolver struct\n- IsPathArgument(arg): true if contains `/` or starts with `.` or `~`\n- Resolve(query): path detection -\u003e alias lookup -\u003e zoxide query -\u003e TUI fallback\n- After alias or zoxide resolution, validate directory exists on disk\n- If directory not found after resolution, print \"Directory not found: {path}\" and exit 1\n- On TUI fallback: return a FallbackResult containing the query string for pre-filling the filter\n- Wire into portal open: when FallbackResult returned, launch TUI with query as initial filter text in session list\n\n**Acceptance Criteria**:\n- [ ] Path-like arguments (containing `/`, starting with `.` or `~`) resolved directly as paths\n- [ ] Non-path arguments checked against alias store first\n- [ ] Alias miss falls through to zoxide query\n- [ ] Zoxide miss (or not installed) falls through to TUI fallback\n- [ ] TUI fallback pre-fills the query as filter text in the session list\n- [ ] Resolved directory validated; \"Directory not found: {path}\" and exit 1 if missing\n- [ ] Zoxide skipped silently when not installed\n\n**Tests**:\n- path-like argument resolved directly (contains /)\n- path-like argument resolved directly (starts with .)\n- path-like argument resolved directly (starts with ~)\n- non-path argument resolved via alias\n- alias miss falls through to zoxide\n- zoxide miss falls through to TUI fallback\n- TUI fallback includes query string for filter pre-fill\n- resolved directory validated for existence\n- non-existent resolved directory prints error and exits 1\n- zoxide not installed skipped silently\n- query matches alias; alias path used (not zoxide)\n\n**Edge Cases**:\n- Query matches both alias and zoxide: alias wins (alias is checked first)\n- Resolved directory does not exist: error message and exit 1\n- Path-like query (e.g., ./mydir): treated as path, not sent through alias/zoxide chain\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Query Resolution section","parent":"tick-0c342f","created":"2026-02-22T22:07:01Z","updated":"2026-02-23T11:16:41Z"}
{"id":"tick-83fe89","title":"Shell Init for Zsh","status":"open","priority":2,"description":"**Problem**: Portal needs a `portal init zsh` command that outputs shell integration: the `x()` and `xctl()` shell functions plus tab completions wired to the function names.\n\n**Solution**: Implement `portal init` Cobra command with zsh subcommand/argument. Emit shell functions that route `x` to `portal open` and `xctl` to `portal`. Emit Cobra-generated completions. Wire completions to function names via `compdef`.\n\n**Outcome**: `eval \"$(portal init zsh)\"` sets up shell functions and tab completions for zsh.\n\n**Do**:\n- Create cmd/init.go with `portal init` command accepting shell name as positional argument\n- For zsh: emit `function x() { portal open \"$@\" }` and `function xctl() { portal \"$@\" }`\n- Emit Cobra-generated zsh completions via rootCmd.GenZshCompletion()\n- Wire completions to function names: `compdef x=portal` and `compdef xctl=portal` (or equivalent)\n- All output goes to stdout for eval consumption\n- The init script is the single source of shell integration per spec\n\n**Acceptance Criteria**:\n- [ ] `portal init zsh` emits x() function routing to portal open\n- [ ] `portal init zsh` emits xctl() function routing to portal\n- [ ] Tab completions emitted for zsh\n- [ ] Completions wired to x and xctl names (not just portal binary)\n- [ ] Output is valid zsh that can be eval'd\n\n**Tests**:\n- init zsh outputs x function definition\n- init zsh outputs xctl function definition\n- init zsh outputs completion setup\n- completions wired to x and xctl names\n- output is valid shell syntax\n\n**Context**:\n\u003e Per spec: \"portal init also emits shell tab completions for the portal binary (generated by Cobra). The init script is the single source of shell integration -- functions, aliases, and completions are all emitted together.\" Completions must work for the shell function names: \"xctl\u003cTAB\u003e completes subcommands (e.g., compdef xctl=portal for zsh).\"\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Shell Functions, CLI Interface (portal init)","parent":"tick-0c342f","created":"2026-02-22T22:07:02Z","updated":"2026-02-23T11:19:29Z"}
{"id":"tick-457428","title":"Shell Init Custom Command Names","status":"open","priority":2,"description":"**Problem**: The `portal init` command needs a `--cmd` flag that customizes the shell function names. `portal init zsh --cmd p` should emit `p()` and `pctl()` instead of `x()` and `xctl()`.\n\n**Solution**: Add a `--cmd` string flag to `portal init`. When provided, use the custom name as the launcher function and append `ctl` for the control plane function. Wire completions to the custom names.\n\n**Outcome**: `eval \"$(portal init zsh --cmd p)\"` creates `p()` and `pctl()` with completions wired to those names.\n\n**Do**:\n- Add --cmd string flag to portal init command (default: \"x\")\n- Launcher function name: value of --cmd (e.g., \"p\")\n- Control plane function name: value of --cmd + \"ctl\" (e.g., \"pctl\")\n- Emit functions with custom names\n- Wire completions to custom names (e.g., `compdef p=portal` and `compdef pctl=portal`)\n\n**Acceptance Criteria**:\n- [ ] --cmd p emits p() and pctl() functions\n- [ ] Completions wired to custom names\n- [ ] Default (no --cmd) emits x() and xctl()\n- [ ] Custom names work for all supported shells\n\n**Tests**:\n- cmd flag changes function names\n- default without cmd flag uses x and xctl\n- completions wired to custom names\n- ctl suffix appended to cmd name\n\n**Edge Cases**:\n- cmd name conflicts with shell builtins: not Portal's concern; user's choice\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Architecture (Command names configurable via --cmd), Shell Functions","parent":"tick-0c342f","created":"2026-02-22T22:07:03Z","updated":"2026-02-23T11:19:41Z"}
{"id":"tick-19ad25","title":"Shell Init for Bash and Fish","status":"open","priority":2,"description":"**Problem**: Portal needs `portal init bash` and `portal init fish` commands that emit shell-specific functions and completions. Unsupported shell names should produce an error.\n\n**Solution**: Extend portal init to support bash and fish alongside zsh. Each shell gets appropriate syntax for function definitions and completions. Unsupported shell names produce an error with exit code 2.\n\n**Outcome**: portal init works for bash, zsh, and fish. Unsupported shells produce a clear error.\n\n**Do**:\n- Implement bash output: bash function syntax, Cobra bash completions\n- Implement fish output: fish function syntax, Cobra fish completions\n- Validate shell argument: must be \"bash\", \"zsh\", or \"fish\"\n- Unsupported shell: print error message to stderr, exit 2 (invalid usage per spec exit codes)\n- No powershell support per spec (Portal wraps tmux, which doesn't run on Windows)\n\n**Acceptance Criteria**:\n- [ ] `portal init bash` emits valid bash functions and completions\n- [ ] `portal init fish` emits valid fish functions and completions\n- [ ] Unsupported shell name prints error and exits with code 2\n- [ ] bash/zsh/fish are the only supported shells\n- [ ] --cmd flag works for all three shells\n\n**Tests**:\n- init bash outputs valid bash syntax\n- init fish outputs valid fish syntax\n- unsupported shell returns exit code 2\n- unsupported shell prints error message\n- cmd flag works with bash\n- cmd flag works with fish\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- CLI Interface (portal init, Supported shells)","parent":"tick-0c342f","created":"2026-02-22T22:07:04Z","updated":"2026-02-23T11:19:54Z"}
{"id":"tick-b92526","title":"File Browser Alias Shortcut","status":"open","priority":2,"description":"**Problem**: The file browser needs an `a` shortcut that prompts for an alias name and saves the highlighted directory as an alias. The directory is git-root-resolved before saving. No session is started.\n\n**Solution**: Handle the `a` key in the file browser. Prompt for an alias name via inline text input. On confirmation, resolve the highlighted directory to git root, then save to the aliases file via AliasStore. No session creation occurs.\n\n**Outcome**: Pressing `a` in the file browser creates an alias for the highlighted directory without starting a session.\n\n**Do**:\n- Handle `a` key in file browser: enter alias prompt mode\n- Render inline text input for alias name\n- On Enter: validate non-empty name, resolve highlighted directory to git root, call AliasStore.Set(name, resolvedDir), save\n- On Esc: cancel, return to browser\n- If alias name already exists, overwrite (per spec: \"setting an alias that already exists overwrites it\")\n- No session is started after alias creation\n\n**Acceptance Criteria**:\n- [ ] `a` key prompts for alias name\n- [ ] Enter confirms and saves alias\n- [ ] Directory git-root-resolved before saving\n- [ ] Alias stored in ~/.config/portal/aliases\n- [ ] No session started after alias creation\n- [ ] Esc cancels alias prompt\n- [ ] Existing alias name overwrites silently\n\n**Tests**:\n- a key enters alias prompt\n- enter saves alias with git-root-resolved path\n- esc cancels alias prompt\n- empty alias name not saved\n- existing alias name overwrites\n- no session started after alias creation\n\n**Context**:\n\u003e Per spec: \"Add alias: a on a highlighted directory prompts for an alias name. Saves to ~/.config/portal/aliases (directory is resolved to git root first). No session is started.\"\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- File Browser (Add alias) section","parent":"tick-0c342f","created":"2026-02-22T22:07:05Z","updated":"2026-02-23T11:20:04Z"}
{"id":"tick-d5a1e0","title":"Phase 5: Inside-tmux Mode, Session Management, and Filter Mode","status":"open","priority":2,"parent":"tick-77cbba","created":"2026-02-22T23:00:00Z","updated":"2026-02-22T23:00:00Z"}
{"id":"tick-e1b2c3","title":"Inside-tmux Detection and Switch-Client","status":"open","priority":2,"description":"**Problem**: Portal always uses exec tmux attach-session to connect to sessions, but when running inside an existing tmux session this would nest tmux (which tmux prevents). Portal needs to detect when it is inside tmux and use switch-client instead of attach.\n\n**Solution**: Create an InsideTmux() detection function that checks the TMUX environment variable. Introduce an abstraction (e.g., SessionConnector interface or mode flag) that selects between attach-session (outside) and switch-client (inside). Wire this into the existing session selection flow so that Enter on a session uses the correct tmux command. When inside tmux, Portal exits normally after issuing switch-client (no exec/process replacement needed).\n\n**Outcome**: Selecting a session from the TUI while inside tmux issues tmux switch-client -t \u003cname\u003e and Portal exits cleanly. Outside tmux, existing exec tmux attach-session behaviour is unchanged.\n\n**Do**:\n- Create internal/tmux/detect.go with InsideTmux() bool -- checks os.Getenv(\"TMUX\") is non-empty\n- Create CurrentSessionName() (string, error) -- runs tmux display-message -p '#{session_name}' to get current session\n- Add SwitchClient(name string) error method to TmuxClient -- runs tmux switch-client -t \u003cname\u003e\n- Modify the session selection handler in cmd/open.go: if InsideTmux(), call SwitchClient then os.Exit(0) instead of syscall.Exec with attach-session\n- Ensure the TUI model carries the insideTmux flag so downstream handlers know which path to take\n\n**Acceptance Criteria**:\n- [ ] InsideTmux() returns true when TMUX env var is set and non-empty\n- [ ] InsideTmux() returns false when TMUX env var is unset or empty\n- [ ] Session selection inside tmux calls tmux switch-client -t \u003cname\u003e\n- [ ] Session selection outside tmux calls exec tmux attach-session -t \u003cname\u003e (unchanged)\n- [ ] Portal exits normally (not exec) after switch-client\n- [ ] All tests pass\n\n**Tests**:\n- InsideTmux returns true when TMUX is set\n- InsideTmux returns false when TMUX is unset\n- InsideTmux returns false when TMUX is empty string\n- session selection inside tmux calls switch-client\n- session selection outside tmux calls attach-session\n- CurrentSessionName returns session name from tmux output\n\n**Edge Cases**:\n- TMUX env var set but empty: treated as outside tmux (empty string is falsy)\n- TMUX var points to dead session: switch-client will fail with tmux error; this is handled at the tmux command layer (error returned to caller)\n\n**Context**:\n\u003e Per spec: \"Portal detects if it's running inside an existing tmux session via the TMUX environment variable.\" Inside tmux, switch-client is used instead of attach. \"No exec is needed -- switch-client is a tmux command sent to the server, not a process replacement. Portal exits normally after issuing the tmux commands.\"\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Running Inside tmux (Detection, Behavior, Session Actions), Process Handoff sections.","parent":"tick-d5a1e0","created":"2026-02-22T23:00:01Z","updated":"2026-02-22T23:00:01Z"}
{"id":"tick-f4d5e6","title":"Inside-tmux Session List Exclusion and Header","status":"open","priority":2,"description":"**Problem**: When running inside tmux, the current session appears in the session list. Selecting it would switch-client to the session you are already in, which is confusing and pointless. The user also has no visual indicator of which session they are currently in.\n\n**Solution**: When InsideTmux() is true, call CurrentSessionName() to get the current session, filter it out of the session list before display, and render a header line showing the current session name (e.g., \"Current: my-project-x7k2m9\"). When all sessions are filtered out (only current session running), show \"No other sessions\" empty state instead of \"No active sessions\".\n\n**Outcome**: Inside tmux, the TUI excludes the current session from the list, shows a header with the current session name, and displays \"No other sessions\" when no other sessions exist.\n\n**Do**:\n- In the TUI model Init or sessionsMsg handler, if insideTmux, call CurrentSessionName() and store as currentSession\n- Filter sessions: remove any session where Name == currentSession\n- In View(), if insideTmux, render \"Current: {currentSession}\" as the first line before the SESSIONS header\n- Change empty state text: if insideTmux and filtered list empty, render \"No other sessions\" instead of \"No active sessions\"\n- Ensure [n] new in project... option remains visible in all states\n\n**Acceptance Criteria**:\n- [ ] Current session excluded from session list when inside tmux\n- [ ] Header shows \"Current: {session_name}\" when inside tmux\n- [ ] No header shown when outside tmux\n- [ ] \"No other sessions\" displayed when only current session exists\n- [ ] \"No active sessions\" still used when outside tmux with zero sessions\n- [ ] [n] new in project... always visible\n- [ ] All tests pass\n\n**Tests**:\n- current session excluded from list inside tmux\n- header renders current session name inside tmux\n- no header rendered outside tmux\n- empty state shows \"No other sessions\" when only current session\n- empty state shows \"No active sessions\" outside tmux\n- multiple sessions minus current renders correctly\n- very long current session name renders in header without truncation\n\n**Edge Cases**:\n- Only one session running (the current one): list is empty after exclusion, \"No other sessions\" shown\n- Current session name very long: header still renders fully\n\n**Context**:\n\u003e Per spec: \"Current session is excluded from the session list (you're already in it). Header shows current session name for context (e.g., from TMUX env var parsing or tmux display-message -p '#{session_name}').\" The spec shows a distinct empty state: \"No other sessions\" for the inside-tmux case.\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- TUI Differences When Inside tmux, Empty States sections.","parent":"tick-d5a1e0","created":"2026-02-22T23:00:02Z","updated":"2026-02-22T23:00:02Z"}
{"id":"tick-a7b8c9","title":"Inside-tmux New Session Creation","status":"open","priority":2,"description":"**Problem**: When inside tmux, creating a new session with the standard tmux new-session -A -s \u003cname\u003e -c \u003cdir\u003e followed by exec would attempt to nest tmux. New sessions must be created detached, then switch-client used to move to them.\n\n**Solution**: Modify the session creation flow to detect inside-tmux mode. When inside tmux, use tmux new-session -d -s \u003cname\u003e -c \u003cdir\u003e (detached) followed by tmux switch-client -t \u003cname\u003e. When outside tmux, retain the existing exec tmux new-session -A -s \u003cname\u003e -c \u003cdir\u003e behaviour.\n\n**Outcome**: Creating a new session from the project picker or file browser while inside tmux creates the session detached and switches to it. Outside tmux, existing behaviour unchanged.\n\n**Do**:\n- Add NewSessionDetached(name, dir string) error to TmuxClient -- runs tmux new-session -d -s \u003cname\u003e -c \u003cdir\u003e\n- Modify SessionCreator.CreateFromDir to accept an insideTmux flag (or use the SessionConnector pattern)\n- When insideTmux: call NewSessionDetached then SwitchClient, then exit normally\n- When outside: call existing NewSession (with -A flag) then exec handoff\n- Wire through from both TUI project selection and file browser selection paths\n\n**Acceptance Criteria**:\n- [ ] Inside tmux: new session created with -d flag (detached)\n- [ ] Inside tmux: switch-client called after detached creation\n- [ ] Inside tmux: Portal exits normally (no exec)\n- [ ] Outside tmux: new-session with -A flag and exec handoff (unchanged)\n- [ ] Session name collision retry works in detached mode\n- [ ] All tests pass\n\n**Tests**:\n- inside tmux creates session detached then switches\n- outside tmux creates session with exec handoff\n- detached creation uses -d flag not -A flag\n- switch-client called with correct session name\n- session name collision triggers regeneration in detached mode\n\n**Edge Cases**:\n- Session name collision during detached creation: GenerateSessionName retry logic applies identically; the collision check uses tmux has-session which works regardless of attach mode\n\n**Context**:\n\u003e Per spec: \"New session from project: tmux new-session -d -s \u003cname\u003e -c \u003cdir\u003e then tmux switch-client -t \u003cname\u003e\" for inside-tmux case. The -d flag creates the session without attaching. switch-client then moves the current client to it.\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Inside tmux: Session Actions, tmux Integration (Create detached) sections.","parent":"tick-d5a1e0","created":"2026-02-22T23:00:03Z","updated":"2026-02-22T23:00:03Z"}
{"id":"tick-d1e2f3","title":"Inside-tmux CLI Command Routing","status":"open","priority":2,"description":"**Problem**: CLI quick-start paths (portal open ., portal open \u003cpath\u003e, portal open \u003cquery\u003e) and portal attach use exec to hand off to tmux. Inside tmux, these must use detached creation + switch-client (for new sessions) or switch-client (for attach) instead of exec.\n\n**Solution**: Add InsideTmux() check to all CLI command paths that interact with tmux sessions. For portal open (quick-start): create session detached then switch-client. For portal attach: switch-client instead of attach-session. Portal exits normally after these operations when inside tmux.\n\n**Outcome**: All CLI paths work correctly inside tmux. portal open . creates a detached session and switches. portal attach \u003cname\u003e switches to the named session. No exec calls inside tmux.\n\n**Do**:\n- In cmd/open.go quick-start path: check InsideTmux(); if true, use NewSessionDetached + SwitchClient instead of exec NewSession\n- In cmd/attach.go (or wherever portal attach is handled): check InsideTmux(); if true, call SwitchClient instead of exec attach-session\n- Ensure query resolution chain (alias -\u003e zoxide -\u003e fallback) still works identically; only the final tmux command changes\n- All paths exit with os.Exit(0) after successful switch-client\n- Error handling: if switch-client fails (e.g., session killed between lookup and switch), print error and exit 1\n\n**Acceptance Criteria**:\n- [ ] portal open . inside tmux creates detached session and switches\n- [ ] portal open \u003cpath\u003e inside tmux creates detached session and switches\n- [ ] portal open \u003cquery\u003e inside tmux creates detached session and switches (after resolution)\n- [ ] portal attach \u003cname\u003e inside tmux calls switch-client\n- [ ] All CLI paths use exec outside tmux (unchanged)\n- [ ] Error printed and exit 1 if switch-client fails\n- [ ] All tests pass\n\n**Tests**:\n- open dot inside tmux uses detached creation and switch-client\n- open path inside tmux uses detached creation and switch-client\n- attach inside tmux uses switch-client\n- open dot outside tmux uses exec (unchanged)\n- attach outside tmux uses exec attach-session (unchanged)\n- switch-client failure prints error and exits 1\n\n**Edge Cases**:\n- TMUX set but session killed before switch: switch-client returns error; Portal prints error message and exits 1\n\n**Context**:\n\u003e Per spec: \"CLI commands also use switch-client instead of attach: x ., x \u003cpath\u003e, x \u003cquery\u003e -\u003e create session detached, then switch-client. xctl attach \u003cname\u003e -\u003e switch-client to the named session.\"\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- CLI Commands Inside tmux, Running Inside tmux sections.","parent":"tick-d5a1e0","created":"2026-02-22T23:00:04Z","updated":"2026-02-22T23:00:04Z"}
{"id":"tick-b4c5d6","title":"Kill Session with Confirmation","status":"open","priority":2,"description":"**Problem**: Users cannot kill tmux sessions from the TUI. The K shortcut is documented in the spec but not yet implemented. Killing requires a confirmation prompt to prevent accidental destruction.\n\n**Solution**: Handle the K key in the session list TUI. When pressed on a highlighted session, display a confirmation prompt: \"Kill session '\u003cname\u003e'? (y/n)\". On y, call tmux kill-session -t \u003cname\u003e, refresh the session list, and adjust cursor position. On n or Esc, cancel and return to normal mode. The confirmation is a TUI state (e.g., confirmKill mode) that intercepts all keypresses.\n\n**Outcome**: Pressing K on a session shows a confirmation prompt. Confirming kills the session via tmux and refreshes the list. Declining returns to normal navigation.\n\n**Do**:\n- Add confirmKill state to the TUI model with pendingKillName string\n- Handle K key in normal mode: if cursor is on a session (not the [n] option), enter confirmKill state\n- In confirmKill state: render \"Kill session '\u003cname\u003e'? (y/n)\" at the bottom or inline\n- Handle y: call TmuxClient.KillSession(name), re-fetch sessions, adjust cursor if needed\n- Handle n or Esc: return to normal mode, clear confirmKill state\n- Add KillSession(name string) error to TmuxClient -- runs tmux kill-session -t \u003cname\u003e\n- After kill, re-fetch session list via a tea.Cmd\n- If cursor was on last item and it was killed, move cursor up\n- K on [n] new in project... option is a no-op\n\n**Acceptance Criteria**:\n- [ ] K on a session shows \"Kill session '\u003cname\u003e'? (y/n)\" prompt\n- [ ] y confirms kill and refreshes session list\n- [ ] n cancels and returns to normal mode\n- [ ] Esc cancels and returns to normal mode\n- [ ] Session list refreshed after kill (killed session removed)\n- [ ] Cursor adjusted if killed session was last in list\n- [ ] K on [n] option is no-op\n- [ ] All tests pass\n\n**Tests**:\n- K enters confirmation mode with session name\n- y in confirmation mode triggers kill and refresh\n- n in confirmation mode cancels\n- Esc in confirmation mode cancels\n- session list refreshes after kill\n- cursor adjusts when last session killed\n- K on new-in-project option is no-op\n- killing last remaining session shows empty state\n\n**Edge Cases**:\n- Killing last session: after refresh, empty state (\"No active sessions\" or \"No other sessions\") displayed\n- Killing current session inside tmux: tmux kill-session works on any session; if the user somehow targets the current session (shouldn't appear in list inside tmux, but defensively), tmux handles it. Per spec, current session is excluded from list when inside tmux, so this case is prevented by Task 5-2.\n\n**Context**:\n\u003e Per spec: \"Kill confirmation: Pressing K prompts for confirmation before killing the selected session: 'Kill session myapp? (y/n)'.\" Kill command is tmux kill-session -t \u003cname\u003e, same inside and outside tmux.\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Keyboard Shortcuts (Kill confirmation), tmux Integration (Kill session) sections.","parent":"tick-d5a1e0","created":"2026-02-22T23:00:05Z","updated":"2026-02-22T23:00:05Z"}
{"id":"tick-e7f8a9","title":"Rename Session with Inline Input","status":"open","priority":2,"description":"**Problem**: Users cannot rename tmux sessions from the TUI. The R shortcut is documented in the spec but not yet implemented. Renaming requires an inline text input pre-filled with the current name.\n\n**Solution**: Handle the R key in the session list TUI. When pressed on a highlighted session, enter rename mode: display an inline text input pre-filled with the current session name. Enter confirms and calls tmux rename-session. Esc cancels. After successful rename, refresh the session list.\n\n**Outcome**: Pressing R on a session shows an inline text input. Confirming renames the session via tmux and refreshes the list. Cancelling returns to normal navigation.\n\n**Do**:\n- Add renameMode state to the TUI model with renameInput (Bubble Tea textinput component), renameTarget string\n- Handle R key in normal mode: if cursor is on a session, enter renameMode, initialise textinput with current name\n- In renameMode: render the text input inline (replacing the session row or at bottom)\n- Handle Enter: validate non-empty, call TmuxClient.RenameSession(oldName, newName), re-fetch sessions\n- Handle Esc: cancel rename, return to normal mode\n- Add RenameSession(oldName, newName string) error to TmuxClient -- runs tmux rename-session -t \u003coldName\u003e \u003cnewName\u003e\n- After rename, re-fetch session list, cursor stays at same index\n- R on [n] new in project... option is a no-op\n\n**Acceptance Criteria**:\n- [ ] R on a session enters rename mode with pre-filled text input\n- [ ] Enter confirms rename and refreshes session list\n- [ ] Esc cancels rename and returns to normal mode\n- [ ] tmux rename-session called with correct old and new names\n- [ ] Empty name input does not trigger rename\n- [ ] R on [n] option is no-op\n- [ ] All tests pass\n\n**Tests**:\n- R enters rename mode with current name pre-filled\n- Enter in rename mode calls rename-session and refreshes\n- Esc in rename mode cancels without renaming\n- empty input does not trigger rename\n- R on new-in-project option is no-op\n- session list refreshes after successful rename\n- renamed session appears with new name in list\n\n**Edge Cases**:\n- Invalid characters in name: tmux rename-session handles validation; if tmux returns an error, display it and stay in rename mode or return to normal mode\n- Collision with existing session: tmux rename-session returns an error if the new name already exists; Portal should display the error and not leave the session in a broken state\n\n**Context**:\n\u003e Per spec: \"Rename prompt: Pressing R shows an inline text input pre-filled with the current session name. Enter confirms, Esc cancels.\" tmux rename-session works from outside the session, so renaming is available in all contexts.\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Keyboard Shortcuts (Rename prompt), Session Naming (Renaming), tmux Integration (Rename session) sections.","parent":"tick-d5a1e0","created":"2026-02-22T23:00:06Z","updated":"2026-02-22T23:00:06Z"}
{"id":"tick-c1d2e3","title":"Filter Mode Activation and Fuzzy Matching","status":"open","priority":2,"description":"**Problem**: With many sessions, users need a way to quickly narrow down the list. The spec defines a filter mode activated by / that fuzzy-matches session names, but it is not yet implemented.\n\n**Solution**: Add a filterMode state to the session list TUI. When / is pressed, enter filter mode: show a filter input at the bottom (e.g., \"filter: _\"), capture all subsequent keystrokes as filter text, fuzzy-match against session names, and display only matching sessions. The [n] new in project... option is always visible regardless of filter. Arrow keys still navigate the filtered results. Enter selects the highlighted item.\n\n**Outcome**: / activates filter mode. Typing narrows the session list by fuzzy match. [n] new in project... always visible. Enter selects from filtered results.\n\n**Do**:\n- Add filterMode bool, filterText string to the TUI model\n- Handle / key in normal mode: set filterMode = true, filterText = \"\"\n- In filterMode, all rune keypresses append to filterText\n- Implement fuzzy matching: filter sessions where name fuzzy-matches filterText (use a simple contains or subsequence match)\n- Compute filteredSessions on each filterText change\n- View renders only filteredSessions when filterMode is active\n- [n] new in project... always rendered at bottom regardless of filter\n- Arrow keys / j/k navigate filteredSessions\n- Enter on highlighted item: select session (or [n] option) -- same as normal mode\n- Cursor resets to 0 when filter text changes\n- Render \"filter: {text}\" at the bottom of the session list\n- Shortcut keys (n, K, R, q) lose their shortcut meaning in filter mode -- they become typeable characters\n\n**Acceptance Criteria**:\n- [ ] / activates filter mode with empty filter\n- [ ] Typing narrows session list by fuzzy match\n- [ ] [n] new in project... always visible during filtering\n- [ ] Arrow keys navigate filtered results\n- [ ] Enter selects highlighted item from filtered list\n- [ ] Filter input rendered at bottom\n- [ ] Shortcut keys (n, K, R, q) are typeable in filter mode\n- [ ] Cursor resets to 0 when filter changes\n- [ ] All tests pass\n\n**Tests**:\n- slash activates filter mode\n- typing narrows session list\n- fuzzy match filters correctly (subsequence matching)\n- new-in-project option always visible during filter\n- enter selects from filtered list\n- shortcut keys are typeable in filter mode\n- cursor resets when filter text changes\n- no sessions match filter shows empty filtered list with new-in-project visible\n- single character filter works correctly\n\n**Edge Cases**:\n- No sessions match filter: empty list shown, but [n] new in project... still visible and selectable\n- Single character filter: matches all sessions containing that character\n\n**Context**:\n\u003e Per spec: \"Press /. A filter input appears at the bottom of the list. All subsequent keystrokes are treated as filter input -- shortcut keys (n, k, K, etc.) lose their shortcut meaning and become typeable characters.\" Fuzzy matching against session names. \"The [n] new in project... option is always visible and never filtered out.\"\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Filter Mode section.","parent":"tick-d5a1e0","created":"2026-02-22T23:00:07Z","updated":"2026-02-22T23:00:07Z"}
{"id":"tick-f4a5b6","title":"Filter Mode Exit Behaviour","status":"open","priority":2,"description":"**Problem**: Once in filter mode, users need clear ways to exit. The spec defines two exit paths: Backspace on empty filter exits mode, and Esc clears filter and exits mode. These are not yet implemented.\n\n**Solution**: Extend the filter mode key handling. Backspace removes the last character from filterText; if filterText is already empty, exit filter mode (restore full session list). Esc clears filterText and exits filter mode regardless of current filter state.\n\n**Outcome**: Backspace progressively removes filter characters and exits mode when empty. Esc immediately clears and exits. Both restore the full unfiltered session list.\n\n**Do**:\n- In filterMode, handle Backspace: if filterText non-empty, remove last character and re-filter; if filterText empty, exit filterMode\n- In filterMode, handle Esc: set filterText = \"\", set filterMode = false, restore full session list\n- When exiting filter mode, reset cursor to 0 (or optionally preserve selection if the previously highlighted session is still in the full list)\n- Ensure that after exiting filter mode, all shortcut keys (n, K, R, q, /) work again\n- q and other quit keys should NOT quit the app while in filter mode -- they are typeable characters per Task 5-7\n\n**Acceptance Criteria**:\n- [ ] Backspace removes last filter character\n- [ ] Backspace on empty filter exits filter mode\n- [ ] Esc clears filter and exits filter mode\n- [ ] Full session list restored after exiting filter mode\n- [ ] Shortcut keys work again after exiting filter mode\n- [ ] q does not quit while in filter mode\n- [ ] All tests pass\n\n**Tests**:\n- backspace removes last filter character\n- backspace on empty filter exits filter mode\n- esc clears filter and exits filter mode\n- full session list restored after exit\n- shortcut keys functional after filter mode exit\n- q in filter mode types 'q' instead of quitting\n- rapid backspace presses drain filter then exit mode\n- esc with active filter clears and exits in one action\n\n**Edge Cases**:\n- Rapid Backspace presses: each press removes one character; when empty, next press exits mode. No special debouncing needed.\n- Filter active with no matches: Esc still clears and exits; Backspace still works character by character\n\n**Context**:\n\u003e Per spec: \"Backspace deletes the last filter character; if the filter is already empty, exits filter mode. Esc clears the filter and exits filter mode.\" Outside filter mode, all single-key shortcuts work as documented.\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Filter Mode section.","parent":"tick-d5a1e0","created":"2026-02-22T23:00:08Z","updated":"2026-02-22T23:00:08Z"}
{"id":"tick-d7e8f9","title":"List Command with TTY-Aware Output","status":"open","priority":2,"description":"**Problem**: Portal has no portal list (xctl list) command. Users need a CLI command that lists sessions with TTY-aware output: full details on a terminal, names only when piped. Override flags --short and --long are needed for scripting.\n\n**Solution**: Implement the portal list Cobra command. Detect whether stdout is a TTY using os.Stdout.Stat() and checking for os.ModeCharDevice. Output full details (name, attached/detached status, window count) on TTY, names only when piped. --short forces names-only, --long forces full details. When no sessions exist, output nothing and exit 0.\n\n**Outcome**: portal list outputs TTY-aware session information. --short and --long override detection. Empty output and exit 0 when no sessions.\n\n**Do**:\n- Create cmd/list.go with Cobra command for portal list\n- Add --short and --long boolean flags (mutually exclusive)\n- Detect TTY: stat, _ := os.Stdout.Stat(); isTTY := (stat.Mode() \u0026 os.ModeCharDevice) != 0\n- Determine output mode: if --short, names only; if --long, full details; else use TTY detection\n- Call TmuxClient.ListSessions()\n- Full details format: \"{name}    {attached|detached}    {N} window(s)\" per line\n- Names only format: one name per line\n- No sessions: output nothing, exit 0\n- Inside tmux: include ALL sessions (including current) -- the CLI list is always complete per spec\n\n**Acceptance Criteria**:\n- [ ] portal list on TTY shows full details\n- [ ] portal list piped shows names only\n- [ ] --short forces names only even on TTY\n- [ ] --long forces full details even when piped\n- [ ] No sessions produces empty output and exit 0\n- [ ] Window count correctly pluralised\n- [ ] Attached/detached status shown in long format\n- [ ] All sessions included (even current session inside tmux)\n- [ ] All tests pass\n\n**Tests**:\n- TTY output includes name, status, window count\n- piped output shows names only\n- short flag forces names only\n- long flag forces full details\n- no sessions produces empty output\n- exit code is 0 with no sessions\n- all sessions listed inside tmux (no exclusion)\n- window count pluralisation correct\n\n**Edge Cases**:\n- No sessions running (or no tmux server): empty stdout, exit 0\n- Piped to another command: names-only output enables xctl list | fzf pattern\n\n**Context**:\n\u003e Per spec: \"xctl list adapts its output based on whether stdout is a terminal.\" Interactive shows \"flowx-dev    attached    3 windows\", piped shows names only. \"Inside tmux: xctl list includes all sessions (including the current one). The TUI excludes the current session for UX reasons, but the CLI output is always complete.\" \"No sessions: empty stdout, exit 0.\"\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- xctl list TTY-Aware Output, Exit Codes, Scripting \u0026 fzf Integration sections.","parent":"tick-d5a1e0","created":"2026-02-22T23:00:09Z","updated":"2026-02-22T23:00:09Z"}
{"id":"tick-a1b2c4","title":"Attach Command","status":"open","priority":2,"description":"**Problem**: Portal has no portal attach (xctl attach) command. Users need a CLI command to attach to a session by exact name, with inside-tmux awareness (switch-client instead of attach).\n\n**Solution**: Implement the portal attach \u003cname\u003e Cobra command. Look up the session by exact name using tmux has-session. If found, attach (outside tmux) or switch-client (inside tmux). If not found, print \"No session found: {name}\" and exit 1.\n\n**Outcome**: portal attach \u003cname\u003e connects to the named session using the correct tmux command based on context. Clear error message and exit 1 when session not found.\n\n**Do**:\n- Create cmd/attach.go with Cobra command for portal attach\n- Accept exactly one positional argument: session name\n- Call TmuxClient.HasSession(name) to check existence\n- If not found: print \"No session found: {name}\" to stderr, exit 1\n- If found and outside tmux: exec tmux attach-session -t \u003cname\u003e\n- If found and inside tmux: call SwitchClient(name), exit 0\n- Add HasSession(name string) (bool, error) to TmuxClient if not already present -- runs tmux has-session -t \u003cname\u003e, returns true on exit 0\n\n**Acceptance Criteria**:\n- [ ] portal attach \u003cname\u003e attaches to named session outside tmux\n- [ ] portal attach \u003cname\u003e switches to named session inside tmux\n- [ ] \"No session found: {name}\" printed and exit 1 when not found\n- [ ] Exact name matching (no partial/fuzzy matching)\n- [ ] Exit code 0 on success\n- [ ] All tests pass\n\n**Tests**:\n- attach to existing session outside tmux uses exec attach-session\n- attach to existing session inside tmux uses switch-client\n- non-existent session prints error and exits 1\n- exact name match only (no partial matching)\n- session killed between has-session and attach returns error\n\n**Edge Cases**:\n- Partial name match: not supported; exact match only per spec (\"xctl attach \u003cname\u003e\" implies exact name)\n- Ambiguous name: not applicable since tmux has-session uses exact match\n- Session killed between lookup and attach: tmux attach/switch will fail; Portal reports the tmux error\n\n**Context**:\n\u003e Per spec: \"xctl attach \u003cname\u003e -- Attach to session by exact name.\" Errors: \"No session found: {name}\" with exit 1. Inside tmux uses switch-client per CLI Commands Inside tmux section.\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- xctl commands (attach), Attach errors, CLI Commands Inside tmux, Exit Codes sections.","parent":"tick-d5a1e0","created":"2026-02-22T23:00:10Z","updated":"2026-02-22T23:00:10Z"}
{"id":"tick-e3f4d5","title":"Kill Command","status":"open","priority":2,"description":"**Problem**: Portal has no portal kill (xctl kill) command. Users need a CLI command to kill a tmux session by exact name with proper error handling.\n\n**Solution**: Implement the portal kill \u003cname\u003e Cobra command. Check session existence with tmux has-session. If found, kill it with tmux kill-session -t \u003cname\u003e. If not found, print \"No session found: {name}\" and exit 1. No confirmation prompt for the CLI command (the TUI has its own confirmation via K key).\n\n**Outcome**: portal kill \u003cname\u003e kills the named session. Clear error message and exit 1 when session not found. No confirmation needed for CLI usage.\n\n**Do**:\n- Create cmd/kill.go with Cobra command for portal kill\n- Accept exactly one positional argument: session name\n- Call TmuxClient.HasSession(name) to check existence\n- If not found: print \"No session found: {name}\" to stderr, exit 1\n- If found: call TmuxClient.KillSession(name) (reuse method from Task 5-5)\n- Exit 0 on success\n- No confirmation prompt (CLI is non-interactive by design)\n\n**Acceptance Criteria**:\n- [ ] portal kill \u003cname\u003e kills the named session\n- [ ] \"No session found: {name}\" printed and exit 1 when not found\n- [ ] Exit code 0 on success\n- [ ] No confirmation prompt\n- [ ] tmux kill-session -t \u003cname\u003e called\n- [ ] All tests pass\n\n**Tests**:\n- kill existing session calls kill-session and exits 0\n- non-existent session prints error and exits 1\n- kill command uses exact name match\n- no confirmation prompt in CLI mode\n- killing current session inside tmux works (tmux handles it)\n\n**Edge Cases**:\n- Killing current session inside tmux: tmux kill-session -t \u003cname\u003e works even on the current session. tmux will switch the client to the next session or terminate the client if no other sessions exist. Portal does not need special handling.\n- Session name not found: error message and exit 1\n\n**Context**:\n\u003e Per spec: \"xctl kill \u003cname\u003e -- Kill a session.\" Errors: \"No session found: {name}\" with exit 1. The CLI kill command is non-interactive -- the confirmation prompt is only in the TUI (K key).\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- xctl commands (kill), Kill errors, Exit Codes sections.","parent":"tick-d5a1e0","created":"2026-02-22T23:00:11Z","updated":"2026-02-22T23:00:11Z"}
{"id":"tick-b6c7a8","title":"Clean Command","status":"open","priority":2,"description":"**Problem**: Portal has no portal clean (xctl clean) command. Users need a CLI command to remove stale projects (directories that no longer exist on disk) from projects.json without interactive prompts.\n\n**Solution**: Implement the portal clean Cobra command. Load the project store, iterate all projects, check each directory with os.Stat. Remove projects whose directories no longer exist. Print each removal for visibility. Non-interactive -- no confirmation prompts.\n\n**Outcome**: portal clean removes stale projects and prints each removal. Exits 0 regardless of whether any projects were removed.\n\n**Do**:\n- Create cmd/clean.go with Cobra command for portal clean\n- Load ProjectStore\n- Iterate projects, check os.Stat on each path\n- For each non-existent directory: print \"Removed stale project: {name} ({path})\" and mark for removal\n- For permission errors: skip (keep the project, do not print)\n- Save updated project list if any removals occurred\n- Exit 0 in all cases\n- Reuse ProjectStore.CleanStale() from Phase 2 if its signature supports printing, or implement a CLI-specific variant that provides per-removal callbacks\n\n**Acceptance Criteria**:\n- [ ] Removes projects with non-existent directories\n- [ ] Prints \"Removed stale project: {name} ({path})\" for each removal\n- [ ] Does not remove projects with permission errors\n- [ ] No confirmation prompts\n- [ ] Exit 0 even when no stale projects found\n- [ ] Exit 0 when all projects are stale\n- [ ] All tests pass\n\n**Tests**:\n- removes stale project and prints removal message\n- keeps project with existing directory (no output for it)\n- keeps project with permission error\n- no stale projects produces no output\n- all projects stale removes all and prints each\n- multiple stale projects each printed\n- exit code 0 in all cases\n\n**Edge Cases**:\n- No stale projects: no output, exit 0\n- All projects stale: all removed, each printed, exit 0\n- Permission errors: project retained silently (not printed as removed, not printed as error)\n\n**Context**:\n\u003e Per spec: \"xctl clean -- Removes projects whose directories no longer exist on disk. Prints each action taken (e.g., 'Removed stale project: myapp (/Users/lee/Code/myapp)'). Non-interactive -- no confirmation prompts.\"\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Stale Project Cleanup (Via xctl clean), xctl commands (clean) sections.","parent":"tick-d5a1e0","created":"2026-02-22T23:00:12Z","updated":"2026-02-22T23:00:12Z"}
{"id":"tick-a6b7c9","title":"Phase 6: Command Execution, Project Editing, and Distribution","status":"in_progress","priority":2,"parent":"tick-77cbba","created":"2026-02-22T23:30:00Z","updated":"2026-02-23T12:28:16Z"}
{"id":"tick-d9e0f1","title":"Command Flag Parsing (-e and --)","status":"open","priority":2,"description":"**Problem**: Portal's open command does not support passing a command to execute in new sessions. The spec defines two syntaxes: -e/--exec for simple commands and -- (double-dash) for compound commands with arguments. These are mutually exclusive, and both must resolve to an internal command slice early in CLI parsing.\n\n**Solution**: Extend the portal open Cobra command to accept -e/--exec as a string flag and handle -- as an args separator. Parse both into a unified []string command field. Validate mutual exclusivity -- providing both produces an error message and exit code 2. When a command is present, pass it downstream via the existing session creation flow.\n\n**Outcome**: portal open -e \u003ccmd\u003e and portal open [destination] -- \u003ccmd\u003e [args...] both parse into a command slice. Mutual exclusivity is enforced with a clear error message.\n\n**Do**:\n- In cmd/open.go, add -e/--exec string flag to the open command\n- Handle ArgsAfterDash (Cobra provides args after -- via cobra.ArbitraryArgs or manual parsing of os.Args)\n- Parse -e value into a single-element command slice: []string{execFlag}\n- Parse -- args into a command slice: os.Args after the -- separator\n- If both -e and -- are provided, print \"Error: -e/--exec and -- are mutually exclusive\" to stderr and exit 2\n- Store the parsed command in a variable accessible to downstream session creation logic\n- If -e is provided with an empty string, print \"Error: -e/--exec requires a command\" to stderr and exit 2\n- If -- is provided with no subsequent arguments, print \"Error: no command provided after --\" to stderr and exit 2\n- Ensure the destination argument is correctly parsed regardless of command syntax\n\n**Acceptance Criteria**:\n- [ ] -e flag accepted and parsed into command slice\n- [ ] -- separator parsed and subsequent args captured as command slice\n- [ ] Both -e and -- provided produces error and exit 2\n- [ ] -e with empty string produces error and exit 2\n- [ ] -- with no arguments produces error and exit 2\n- [ ] Destination argument correctly identified in both syntaxes\n- [ ] portal open (no flags) works unchanged -- no command, normal TUI flow\n- [ ] All tests pass\n\n**Tests**:\n- parses -e flag into command slice\n- parses -- args into command slice\n- both -e and -- produces exit code 2\n- -e with empty string produces exit code 2\n- -- with no arguments produces exit code 2\n- destination parsed correctly with -e flag (x -e claude myproject)\n- destination parsed correctly with -- syntax (x myproject -- claude --resume)\n- no flags produces nil command (normal flow)\n\n**Edge Cases**:\n- -e with empty string: error, not silently ignored\n- -- with no arguments after it: error, not silently treated as no command\n- Both -e and -- provided: error message names both flags, exit 2\n\n**Context**:\n\u003e Per spec: \"Both are mutually exclusive -- providing both is an error. Both resolve to the same internal command slice early in CLI parsing.\" The -e syntax is for simple commands: x -e claude myproject. The -- syntax is for compound commands: x myproject -- claude --resume --model opus. Exit code 2 is used for invalid usage per the spec's exit code table.\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- x (The Launcher) table, Command execution (-e / --) section, Exit Codes section.","parent":"tick-a6b7c9","created":"2026-02-22T23:30:01Z","updated":"2026-02-22T23:30:01Z"}
{"id":"tick-c2d3e4","title":"Command-Aware Session Creation","status":"open","priority":2,"description":"**Problem**: Session creation does not support executing a command inside the new session. When -e or -- provides a command, Portal must pass it to tmux as a shell-command argument so the command runs then drops to an interactive shell.\n\n**Solution**: Extend the session creation flow (SessionCreator and TmuxClient) to accept an optional command. When a command is provided, construct the tmux shell-command argument as $SHELL -ic '\u003ccmd\u003e; exec $SHELL'. Pass this as the final argument to tmux new-session. This works for both outside-tmux (new-session -A) and inside-tmux (new-session -d) flows.\n\n**Outcome**: New sessions created with a command execute that command on startup and drop to an interactive shell when the command exits. Sessions without commands start the default shell as before.\n\n**Do**:\n- Add an optional command []string parameter to SessionCreator.CreateFromDir (or introduce CreateFromDirWithCommand)\n- In TmuxClient, extend NewSession and NewSessionDetached to accept an optional shellCommand string\n- When command is provided: join the command slice into a single string, construct \"$SHELL -ic '\u003cjoined_cmd\u003e; exec $SHELL'\"\n- For outside-tmux: tmux new-session -A -s \u003cname\u003e -c \u003cdir\u003e \"$SHELL -ic '\u003ccmd\u003e; exec $SHELL'\"\n- For inside-tmux: tmux new-session -d -s \u003cname\u003e -c \u003cdir\u003e \"$SHELL -ic '\u003ccmd\u003e; exec $SHELL'\" then switch-client\n- When no command: omit the shell-command argument entirely (existing behaviour)\n- Handle single quotes in the command by escaping them (replace ' with '\\'')\n- Read $SHELL from os.Getenv(\"SHELL\"); if empty, fall back to /bin/sh\n- Wire from cmd/open.go: pass the parsed command slice through to session creation\n\n**Acceptance Criteria**:\n- [ ] Command passed as tmux shell-command argument in correct format\n- [ ] $SHELL used to construct the shell invocation\n- [ ] Falls back to /bin/sh when $SHELL is not set\n- [ ] Single quotes in command properly escaped\n- [ ] No shell-command argument when no command provided\n- [ ] Works for outside-tmux flow (new-session -A with exec handoff)\n- [ ] Works for inside-tmux flow (new-session -d with switch-client)\n- [ ] All tests pass\n\n**Tests**:\n- command included in tmux new-session as shell-command\n- shell-command format matches $SHELL -ic '\u003ccmd\u003e; exec $SHELL'\n- SHELL env var used in command construction\n- falls back to /bin/sh when SHELL not set\n- single quotes in command escaped correctly\n- no shell-command argument when command is nil/empty\n- outside-tmux session creation with command uses exec handoff\n- inside-tmux session creation with command uses detached + switch-client\n- multi-word command from -- syntax joined correctly\n\n**Edge Cases**:\n- Command containing single quotes: must be escaped to avoid breaking the shell -ic '...' wrapper (e.g., echo 'hello' becomes echo '\\''hello'\\'')\n- $SHELL not set: use /bin/sh as fallback\n- Special shell characters (\u0026, |, ;, etc.): these are intentionally passed through since the command runs inside $SHELL -ic which handles them\n\n**Context**:\n\u003e Per spec: \"The command is passed as tmux's shell-command argument on new-session. Portal uses $SHELL to detect the user's login shell: tmux new-session -A -s \u003cname\u003e -c \u003cdir\u003e \\\"$SHELL -ic '\u003ccmd\u003e; exec $SHELL'\\\"\". This creates the session with a shell that runs the command, then replaces itself with a fresh interactive shell via exec. For inside-tmux: tmux new-session -d -s \u003cname\u003e -c \u003cdir\u003e \\\"$SHELL -ic '\u003ccmd\u003e; exec $SHELL'\\\" then switch-client.\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Command Execution in Sessions, tmux Integration sections.","parent":"tick-a6b7c9","created":"2026-02-22T23:30:02Z","updated":"2026-02-22T23:30:02Z"}
{"id":"tick-f5a6b7","title":"Command-Pending TUI Mode","status":"open","priority":2,"description":"**Problem**: When a command is specified via -e or --, the TUI should skip the session list and show only the project picker. Existing sessions are not displayed because the command applies to new sessions only. There is no visual indication of the pending command.\n\n**Solution**: Add a commandPending mode to the TUI. When the command slice is non-empty, the TUI starts directly in the project picker view (skipping the session list). A banner at the top displays \"Command: \u003ccmd\u003e\" to indicate what will run. The project picker behaves normally -- selecting a project creates a session with the pending command. If query resolution produced a TUI fallback, the query is pre-filled as the filter text in the project picker.\n\n**Outcome**: With a pending command, the TUI opens directly to the project picker with a command banner. Session list is not shown. Project selection creates a session with the command.\n\n**Do**:\n- In the TUI model constructor, accept a command []string and optional queryFilter string\n- If command is non-empty, set initial view to viewProjectPicker (skip viewSessionList)\n- Render \"Command: \u003cjoined_cmd\u003e\" as a banner line at the top of the view\n- The project picker shows projects sorted by last_used with browse option at bottom (same as normal)\n- Hide the [n] new in project... option from session list (it is not shown at all since session list is skipped)\n- Esc in command-pending mode quits the TUI entirely (no session list to return to)\n- If a queryFilter is provided (from TUI fallback in query resolution), pre-fill the project picker's filter\n- Project selection flows through the command-aware session creation from Task 6-2\n- Browse option also applies the pending command to the session created from the browser\n\n**Acceptance Criteria**:\n- [ ] Command-pending mode skips session list, shows project picker directly\n- [ ] Banner displays \"Command: \u003ccmd\u003e\" at the top\n- [ ] Project picker lists projects sorted by last_used with browse option\n- [ ] Selecting a project creates session with the pending command\n- [ ] Esc quits TUI (no session list to return to)\n- [ ] Query filter pre-filled when provided\n- [ ] Browse option creates session with pending command\n- [ ] No command (normal flow) shows session list as before\n- [ ] All tests pass\n\n**Tests**:\n- command-pending mode starts in project picker view\n- banner shows command text\n- session list not displayed in command-pending mode\n- project selection creates session with command\n- esc in command-pending mode quits TUI\n- query filter pre-filled in project picker\n- browse selection applies pending command\n- no command starts in session list view (normal flow unchanged)\n- long command text in banner renders without truncation\n\n**Edge Cases**:\n- No saved projects: empty state (\"No saved projects yet.\") with browse still visible; command banner still shown\n- Query pre-filled as filter: project picker filter mode activates with the query text\n- Long command in banner: render fully, no truncation\n\n**Context**:\n\u003e Per spec: \"When -e or -- is provided, the TUI skips the session list and shows the project picker directly, with a banner indicating the pending command.\" The empty state layout shows \"Command: claude\" as the banner and \"PROJECTS\" as the header. The query resolution fallback pre-fills the query as filter text: \"If a command is pending (-e/--), this opens the project picker\" with filter.\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Empty States (Command pending), x (The Launcher) table, Query Resolution section.","parent":"tick-a6b7c9","created":"2026-02-22T23:30:03Z","updated":"2026-02-22T23:30:03Z"}
{"id":"tick-e8f9a0","title":"Project Picker Edit Mode","status":"open","priority":2,"description":"**Problem**: Users cannot rename projects or manage aliases from the project picker TUI. The spec defines an e shortcut that opens an inline edit for the selected project, allowing renaming and alias management.\n\n**Solution**: Add an editMode state to the project picker. When e is pressed on a highlighted project, display an inline edit with two fields: project name (from projects.json) and aliases (read from ~/.config/portal/aliases filtered to aliases matching the project's directory path). Tab cycles between fields, Enter confirms changes, Esc cancels. Project name changes update projects.json; alias changes update the aliases file.\n\n**Outcome**: Pressing e on a project opens inline edit with name and alias fields. Changes save to the appropriate files. Cancel returns to the project list unchanged.\n\n**Do**:\n- Add editMode state to ProjectPickerModel with editFields: projectName (text input), aliasList (display of current aliases with add/remove)\n- Handle e key in normal mode: if cursor is on a project (not browse option), enter editMode\n- Load current project name from projects.json, load aliases matching project's directory from AliasStore\n- Render inline edit: project name input field, then list of current aliases with [x] to remove, then input to add new alias\n- Tab cycles focus between name field and alias management area\n- Enter confirms: save updated project name via ProjectStore, save alias changes via AliasStore\n- Esc cancels: discard all changes, return to project list\n- e on browse option is a no-op\n- After confirm, refresh project list to show updated name\n\n**Acceptance Criteria**:\n- [ ] e on a project enters edit mode with pre-filled name\n- [ ] Current aliases for the project's directory displayed\n- [ ] Tab cycles between name field and alias area\n- [ ] Enter saves project name and alias changes\n- [ ] Esc cancels without saving\n- [ ] Updated project name reflected in project list after save\n- [ ] Alias additions saved to ~/.config/portal/aliases\n- [ ] Alias removals saved to ~/.config/portal/aliases\n- [ ] e on browse option is no-op\n- [ ] All tests pass\n\n**Tests**:\n- e enters edit mode with current project name\n- aliases for project directory displayed\n- tab cycles between fields\n- enter saves project name change\n- enter saves alias additions\n- enter saves alias removals\n- esc cancels without changes\n- project list refreshes after save\n- e on browse option is no-op\n- edit with no aliases shows empty alias list\n- multiple aliases displayed and manageable\n- alias name collision shows error\n- empty project name not saved\n\n**Edge Cases**:\n- No aliases for the project: alias list shows empty, user can add new ones\n- Multiple aliases: all displayed, each removable independently\n- Alias collision: if the user enters an alias name that already exists (for a different path), show inline error message\n- Empty project name: do not save, keep edit mode active or show validation error\n\n**Context**:\n\u003e Per spec: \"Edit mode: Pressing e opens an inline edit for the selected project. Editable fields: project name (stored in projects.json) and aliases (read/written from ~/.config/portal/aliases, filtered to aliases whose path matches the selected project's directory). Cycle fields with Tab, confirm with Enter, cancel with Esc.\" Project renames update projects.json. Alias changes update the aliases file. Neither affects existing tmux session names.\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Project Picker Interaction (Edit mode), Project Management, Alias Storage sections.","parent":"tick-a6b7c9","created":"2026-02-22T23:30:04Z","updated":"2026-02-22T23:30:04Z"}
{"id":"tick-b1c2d3","title":"Project Picker Remove with Confirmation","status":"open","priority":2,"description":"**Problem**: Users cannot remove a remembered project from the project picker TUI. The spec defines an x shortcut that removes the selected project with a confirmation prompt.\n\n**Solution**: Handle the x key in the project picker. When pressed on a highlighted project, display a confirmation prompt. On confirmation, remove the project from projects.json via ProjectStore.Remove. Adjust cursor position and refresh the project list. On cancel, return to normal navigation.\n\n**Outcome**: Pressing x on a project shows a confirmation prompt. Confirming removes the project from the remembered list. The project list refreshes with the project gone.\n\n**Do**:\n- Add confirmRemove state to ProjectPickerModel with pendingRemovePath string and pendingRemoveName string\n- Handle x key in normal mode: if cursor is on a project (not browse option), enter confirmRemove state\n- Render confirmation prompt (e.g., \"Remove project '\u003cname\u003e'? (y/n)\")\n- Handle y: call ProjectStore.Remove(path), refresh project list, adjust cursor if needed\n- Handle n or Esc: return to normal mode, clear confirmRemove state\n- If cursor was on last project and it was removed, move cursor up\n- x on browse option is a no-op\n- Do NOT remove aliases associated with the project -- aliases are independent of the project registry per spec\n- After removal, if project list is now empty, show \"No saved projects yet.\" empty state\n\n**Acceptance Criteria**:\n- [ ] x on a project shows confirmation prompt\n- [ ] y confirms removal and refreshes project list\n- [ ] n cancels and returns to normal mode\n- [ ] Esc cancels and returns to normal mode\n- [ ] Removed project no longer appears in list\n- [ ] Cursor adjusted if removed project was last in list\n- [ ] x on browse option is no-op\n- [ ] Aliases not removed when project is removed\n- [ ] Empty state shown when last project removed\n- [ ] All tests pass\n\n**Tests**:\n- x enters confirmation mode with project name\n- y confirms removal and refreshes list\n- n cancels removal\n- esc cancels removal\n- removed project gone from list\n- cursor adjusts when last project removed\n- x on browse option is no-op\n- removing last project shows empty state\n- aliases preserved after project removal\n- rapid key presses do not cause double removal\n\n**Edge Cases**:\n- Removing last project: empty state (\"No saved projects yet.\") displayed, browse option still visible\n- Rapid key presses: confirmation state intercepts all keys, preventing double removal\n- Project has aliases: aliases are NOT removed; they are independent per spec (\"Aliases are pure navigation shortcuts -- they map a short name to a directory path. They are independent of the project registry\")\n\n**Context**:\n\u003e Per spec: \"x -- Remove selected project from remembered list (with confirmation)\". Aliases are independent of the project registry and are not affected by project removal. The project store's Remove method handles the persistence.\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Project Picker Interaction (keyboard shortcuts), Project Management sections.","parent":"tick-a6b7c9","created":"2026-02-22T23:30:05Z","updated":"2026-02-22T23:30:05Z"}
{"id":"tick-a4b5c6","title":"tmux Runtime Dependency Check","status":"done","priority":1,"description":"**Problem**: Portal requires tmux at runtime. If tmux is not installed or not on PATH, Portal should display a clear error message and exit rather than failing with an obscure error from exec.LookPath or tmux command execution.\n\n**Solution**: Add a tmux availability check at startup (in the root command's PersistentPreRun or at the start of commands that need tmux). Use exec.LookPath(\"tmux\") to verify tmux is available. If not found, print \"Portal requires tmux. Install with: brew install tmux\" to stderr and exit 1. Commands that do not need tmux (portal version, portal init, portal help) should skip this check.\n\n**Outcome**: Running any tmux-dependent portal command without tmux installed shows a clear install message and exits. Non-tmux commands (version, init, help) work regardless.\n\n**Do**:\n- Create internal/tmux/check.go with CheckTmuxAvailable() error -- uses exec.LookPath(\"tmux\")\n- If LookPath fails, return a descriptive error\n- In cmd/root.go, add PersistentPreRunE that calls CheckTmuxAvailable() for tmux-dependent commands\n- Skip the check for: portal version, portal init, portal help (and their subcommands)\n- Alternatively, add the check to each tmux-dependent command's PreRunE (open, list, attach, kill, clean)\n- Print \"Portal requires tmux. Install with: brew install tmux\" and exit 1 on failure\n- Remove any ad-hoc LookPath checks from other commands (e.g., the one in Task 1-6 attach flow) and centralise here\n\n**Acceptance Criteria**:\n- [ ] Missing tmux prints \"Portal requires tmux. Install with: brew install tmux\" to stderr\n- [ ] Exit code 1 when tmux is missing\n- [ ] portal version works without tmux\n- [ ] portal init works without tmux\n- [ ] portal help works without tmux\n- [ ] portal open fails with message when tmux missing\n- [ ] portal list fails with message when tmux missing\n- [ ] portal attach fails with message when tmux missing\n- [ ] portal kill fails with message when tmux missing\n- [ ] All tests pass\n\n**Tests**:\n- CheckTmuxAvailable returns nil when tmux is on PATH\n- CheckTmuxAvailable returns error when tmux is not on PATH\n- tmux-dependent commands show error when tmux missing\n- portal version does not check for tmux\n- portal init does not check for tmux\n- error message matches spec text exactly\n\n**Edge Cases**:\n- tmux not executable (permissions issue): LookPath may find it but execution will fail; this is caught at command execution time, not at startup\n- Broken symlink to tmux: LookPath finds the binary but it cannot execute; handled similarly to tmux not found\n\n**Context**:\n\u003e Per spec: \"If tmux is somehow missing at runtime, Portal displays: 'Portal requires tmux. Install with: brew install tmux'\". tmux is a runtime dependency, not a build-time dependency. The Homebrew formula declares tmux as a dependency for automatic install, but this check handles edge cases where tmux is removed or Portal is installed manually.\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Runtime Dependency, Distribution sections.","parent":"tick-a6b7c9","created":"2026-02-22T23:30:06Z","updated":"2026-02-23T12:57:55Z","closed":"2026-02-23T12:57:55Z"}
{"id":"tick-d7e8f0","title":"Version Command","status":"open","priority":2,"description":"**Problem**: Portal has no portal version command. Users and package managers need a way to query the installed version.\n\n**Solution**: Add a portal version Cobra command that prints version information. The version string is set at build time via Go linker flags (-ldflags \"-X main.version=...\"). If not set (development builds), display \"dev\" as the version.\n\n**Outcome**: portal version prints the version string. Build-time injection via ldflags sets the version. Development builds show \"dev\".\n\n**Do**:\n- Create cmd/version.go with Cobra command for portal version\n- Declare a package-level var version = \"dev\" in main.go (or cmd/version.go)\n- GoReleaser will set this via ldflags: -X main.version={{.Version}} (or equivalent)\n- Output format: \"portal version {version}\" (e.g., \"portal version 1.2.3\" or \"portal version dev\")\n- No tmux dependency check needed for this command\n\n**Acceptance Criteria**:\n- [ ] portal version prints version string\n- [ ] Default version is \"dev\" when not set at build time\n- [ ] Version injectable via -ldflags \"-X main.version=1.0.0\"\n- [ ] Output format: \"portal version {version}\"\n- [ ] No tmux check on this command\n- [ ] All tests pass\n\n**Tests**:\n- version command outputs version string\n- default version is \"dev\"\n- version set via ldflags overrides default\n- output matches expected format\n\n**Edge Cases**:\n- Version not set at build time: defaults to \"dev\", not empty string or panic\n\n**Context**:\n\u003e Per spec: \"portal version -- Show version information\". This is a direct command on the portal binary. It is listed alongside portal help as a non-tmux command.\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- portal (Direct Commands) table.","parent":"tick-a6b7c9","created":"2026-02-22T23:30:07Z","updated":"2026-02-22T23:30:07Z"}
{"id":"tick-f1a2b3","title":"GoReleaser Configuration","status":"open","priority":2,"description":"**Problem**: Portal needs a cross-platform build and release pipeline. The spec requires macOS (arm64, amd64) and Linux (arm64, amd64) builds distributed via Homebrew tap.\n\n**Solution**: Create a .goreleaser.yaml configuration file that builds for all target platforms, sets version via ldflags, creates GitHub releases, and auto-updates the Homebrew formula in leeovery/homebrew-tools.\n\n**Outcome**: GoReleaser configuration produces cross-platform binaries, GitHub releases, and auto-updated Homebrew formula on tag push.\n\n**Do**:\n- Create .goreleaser.yaml at project root\n- Configure builds: GOOS=darwin/linux, GOARCH=arm64/amd64\n- Set ldflags: -s -w -X main.version={{.Version}}\n- Configure archives: binary name \"portal\", tar.gz for Linux, zip for macOS\n- Configure changelog: auto-generated from git commits\n- Configure brews section: tap repository leeovery/homebrew-tools, formula name \"portal\"\n- Add tmux as a Homebrew dependency in the formula template\n- Add homepage, description, and license fields\n- Configure release section: GitHub release with auto-generated notes\n- Test locally with goreleaser check (validates config syntax)\n\n**Acceptance Criteria**:\n- [ ] .goreleaser.yaml exists at project root\n- [ ] Builds configured for darwin/arm64, darwin/amd64, linux/arm64, linux/amd64\n- [ ] ldflags inject version into main.version\n- [ ] Homebrew tap configured for leeovery/homebrew-tools\n- [ ] tmux declared as Homebrew dependency\n- [ ] goreleaser check passes (config validation)\n- [ ] Binary name is \"portal\"\n\n**Tests**:\n- goreleaser check validates config without errors\n- build targets include all four platform/arch combinations\n- ldflags include version injection\n- Homebrew tap points to correct repository\n- tmux listed as dependency in brew config\n\n**Edge Cases**: None -- this is a static configuration file.\n\n**Context**:\n\u003e Per spec: \"GoReleaser handles cross-platform builds and distribution.\" Target platforms: macOS (arm64, amd64) and Linux (arm64, amd64). \"Distributed via Homebrew tap: brew tap leeovery/tools; brew install portal.\" \"The Homebrew formula declares tmux as a dependency, ensuring it's installed automatically.\"\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Distribution (Target Platforms, Installation Method, Build \u0026 Release) section.","parent":"tick-a6b7c9","created":"2026-02-22T23:30:08Z","updated":"2026-02-22T23:30:08Z"}
{"id":"tick-c4d5e6","title":"GitHub Actions Release Workflow","status":"open","priority":2,"description":"**Problem**: There is no CI/CD pipeline to automate building and releasing Portal. The spec defines a release process triggered by version tag push that runs GoReleaser via GitHub Actions.\n\n**Solution**: Create a GitHub Actions workflow file that triggers on version tag push (v*), checks out the code, sets up Go, and runs GoReleaser. GoReleaser creates the GitHub release with binaries and updates the Homebrew formula. The workflow needs write permissions for contents (to create releases) and a personal access token for cross-repo Homebrew tap updates.\n\n**Outcome**: Pushing a version tag (e.g., v1.0.0) triggers automated build, GitHub release creation, and Homebrew formula update.\n\n**Do**:\n- Create .github/workflows/release.yml\n- Trigger: on push tags matching v* pattern (e.g., v1.0.0, v0.1.0)\n- Steps: checkout with fetch-depth 0 (GoReleaser needs full history), setup Go, run GoReleaser\n- Use goreleaser/goreleaser-action@v6 (or latest)\n- Set GITHUB_TOKEN env var on the GoReleaser step for release creation\n- Set HOMEBREW_TAP_GITHUB_TOKEN env var on the GoReleaser step (sourced from repo secret HOMEBREW_TAP_TOKEN) for cross-repo Homebrew tap push (GoReleaser reads this env var to authenticate when pushing the formula update)\n- Permissions: contents: write (for GitHub releases)\n- GoReleaser args: release --clean\n- Ensure the workflow does NOT trigger on tags without v prefix (tags like 1.0.0 are ignored)\n\n**Acceptance Criteria**:\n- [ ] .github/workflows/release.yml exists\n- [ ] Triggers on push of v* tags only\n- [ ] Checks out code with full git history\n- [ ] Sets up Go toolchain\n- [ ] Runs GoReleaser with release --clean\n- [ ] GITHUB_TOKEN provided for release creation\n- [ ] HOMEBREW_TAP_GITHUB_TOKEN set from HOMEBREW_TAP_TOKEN secret for Homebrew tap updates\n- [ ] Does not trigger on non-v tags or branch pushes\n- [ ] Workflow permissions set correctly\n\n**Tests**:\n- workflow file is valid YAML\n- trigger matches v* tag pattern\n- trigger does not match tags without v prefix\n- GoReleaser action version is current\n- GITHUB_TOKEN and HOMEBREW_TAP_GITHUB_TOKEN referenced\n- checkout uses fetch-depth 0\n- Go version matches go.mod\n\n**Edge Cases**:\n- Tag without v prefix (e.g., 1.0.0): should NOT trigger the workflow; the on.push.tags pattern v* handles this\n- Workflow permissions: contents: write is required for GoReleaser to create GitHub releases; if missing, the release step fails with 403\n\n**Context**:\n\u003e Per spec: \"GitHub Actions workflow triggers GoReleaser on version tag push.\" The release process is: 1. Generate version tag, 2. Push tag, 3. GitHub Actions triggers GoReleaser, 4. GoReleaser builds binaries and creates release, 5. GoReleaser auto-updates Homebrew formula. The Homebrew tap is in a separate repository (leeovery/homebrew-tools), requiring a personal access token with repo scope for cross-repo push. GoReleaser uses the env var HOMEBREW_TAP_GITHUB_TOKEN for authentication.\n\n**Spec Reference**: .workflows/specification/portal/specification.md -- Distribution (Build \u0026 Release) section.","parent":"tick-a6b7c9","created":"2026-02-22T23:30:09Z","updated":"2026-02-23T11:31:06Z"}
